{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Welcome to zkWasm Development Recipe","text":"<p>The zkWasm Development Recipe focuses on building trustless blockchain applications using zkWasm and related technologies. It will start from scratch, from understanding blockchain and zero-knowledge proofs, to learning the basics and architecture of zkWasm, and then to developing a complete application, allowing you to transform from a beginner to an advanced zkWasm developer.</p> <p>Of course, this Development Recipe can serve as both an introductory tutorial for beginners and a reference manual for developing zkWasm applications. Each chapter corresponds to a step in developing a full-stack zkWasm application.</p> <p>Note</p> <p>This is still a work in progress. We will keep updating it with the latest information and best practices.</p>"},{"location":"index.html#learning-experience","title":"Learning Experience","text":"<p>Here's what you can expect from this recipe:</p> <ul> <li>Workflow: A smooth development learning experience following a \"learn - design - develop - test - deploy\" workflow</li> <li>Tools: Useful tools and guidance for developing games, web, and backend applications </li> <li>Guidance: Step-by-step code examples and practical guidance</li> </ul> <p>Content Format:</p> <ul> <li>Text: Clear and concise explanations to help you understand the concepts and principles</li> <li>Code: Step-by-step code examples to guide you through the development process</li> <li>Video: Visual explanations to help you understand the concepts and principles</li> <li>Quiz: Test your understanding of the concepts and principles</li> <li>Supplemental Resources: Additional resources to further enhance your learning</li> <li>FAQ: Answers to frequently asked questions</li> </ul> <p>You will build skills and confidence in the following areas:</p> <ul> <li>Blockchain and zkWasm engineering</li> <li>Application design</li> <li>Frontend development with React, TypeScript, and Web3 libraries</li> <li>Backend development with Rust and zkWasm </li> <li>Environment setup, testing, debugging, and deployment</li> </ul> <p>This will equip you to build your own zkWasm applications from the ground up.</p> <p>Upon completing this Development Recipe, you'll have several exciting paths to explore:</p> <ul> <li>Hackathons: Put your skills to the test by participating in hackathons across various ecosystems and showcasing your zkWasm prowess</li> <li>Entrepreneurship: Embark on an entrepreneurial journey by building your own innovative products and starting a company, with the support of Delphinus Labs</li> <li>Ecosystem Contribution: Contribute to the growth of the zkWasm ecosystem by creating essential tools and libraries, with grants from Delphinus Labs</li> <li>Career Development: Launch your career as a sought-after full-stack developer in the thriving blockchain industry</li> <li>Academic Research: Delve deeper into the academic realm by pursuing research on zkWasm and pushing the boundaries of this cutting-edge technology</li> <li>Discover Opportunities: Discover countless other opportunities to apply your newfound expertise and make your mark in the world of blockchain and zero-knowledge proofs</li> </ul>"},{"location":"index.html#ready-to-get-started","title":"Ready to get started?","text":"<p>Here are a few steps you should follow to ensure a great development experience:</p>"},{"location":"index.html#join-the-discord-community","title":"Join the Discord Community","text":"<p>Delphinus Labs Discord Community </p> <ul> <li>Ask questions, share your ideas, and get help from the community. </li> <li>\"The best way to learn is by teaching.\u201d If you see others who are stuck, help them out! </li> <li>There are also many events and activities organized by the community which you can participate in.</li> </ul>"},{"location":"index.html#join-the-telegram-dev-chat","title":"Join the Telegram Dev Chat","text":"<p>Please DM The Developer Relations Team </p> <ul> <li>Direct Message the developer relations team to be invited into the telegram chat group.</li> <li>You can get help from the developer relations team, also you will be able to connect with other developers. </li> <li>Please also give us your feedback and suggestions on how to improve the development experience.</li> </ul> <p>Let's dive in!</p>"},{"location":"index.html#getting-started","title":"Getting Started","text":"\ud83d\ude80 Quick Tutorial <p>Get started quickly with a hands-on tutorial</p> Start Building \u2192 \ud83d\udd30 Core Concepts <p>Learn the fundamental concepts of blockchain application development</p> Start Learning \u2192 \u2699\ufe0f Setup Guide <p>Set up your development environment</p> Get Ready \u2192 \ud83d\ude80 zkWasm Overview <p>Learn the basics of zkWasm</p> Start Learning \u2192"},{"location":"Core%20Concepts.html","title":"Core Concepts","text":""},{"location":"Core%20Concepts.html#1-understanding-web-application-development","title":"1. Understanding Web Application Development","text":"<p>In modern web application development, the frontend and backend have clear divisions of labor. Although technologies are constantly evolving, one thing remains constant: the frontend is responsible for presenting the state, while the backend is responsible for managing the state.</p> <p>Note</p> <ul> <li>The recipe focuses on web application development due to zkWasm's strong ties with WebAssembly. However, zkWasm is not limited to web applications, you can use zkWasm to develop applications such as games for other platforms.</li> <li>Wasm's widespread support in web browsers makes it easier to integrate zkWasm into web applications.</li> <li>The zkWasm ecosystem and Delphinus Labs provide web-friendly tools and libraries for a streamlined development process.</li> </ul>"},{"location":"Core%20Concepts.html#backend-state-storage-and-transformation","title":"Backend: State Storage and Transformation","text":"<p>The backend is the core of an application, and its main responsibilities include:</p> <ol> <li> <p>State Storage: The backend stores the application's state data, which can be kept in memory or persisted in a database. Common storage methods include relational databases (like MySQL) and non-relational databases (like MongoDB).</p> </li> <li> <p>State Transformation: The backend receives requests from the frontend, transforms the state according to business logic, and returns the new state to the frontend. This process can be seen as a state machine, where each request triggers a state transition.</p> </li> <li> <p>Business Logic: The backend handles complex business logic, such as user authentication, access control, and data validation, ensuring the legitimacy and security of state transitions.</p> </li> </ol>"},{"location":"Core%20Concepts.html#frontend-state-presentation-and-interaction","title":"Frontend: State Presentation and Interaction","text":"<p>The frontend directly faces the user, and its main responsibilities include:</p> <ol> <li> <p>State Presentation: The frontend renders the state data returned by the backend into a user interface. Traditional web pages use HTML to describe content structure and CSS to describe appearance. Modern web applications often use JavaScript frameworks (like React or Vue) to declaratively describe the mapping between UI and state.</p> </li> <li> <p>User Interaction: The frontend handles various user interactions, such as mouse clicks, keyboard input, and touch events. When the user performs an action, the frontend updates the UI state and passes the user's intent to the backend.</p> </li> <li> <p>Local State Management: Although the backend is the main manager of state, the frontend also needs to manage some local UI states, such as the currently selected tab or whether a modal is shown. These states are usually related to specific UI components and do not need to be passed to the backend.</p> </li> </ol>"},{"location":"Core%20Concepts.html#frontend-backend-separation-state-synchronization","title":"Frontend-Backend Separation: State Synchronization","text":"<p>As the division between frontend and backend becomes clearer, frontend-backend separation has become the mainstream model of web development. In this model, the frontend and backend communicate through APIs and need to agree on data formats and communication protocols. We can view the interaction between frontend and backend as a process of synchronizing state from the backend to the frontend: the frontend requests the backend API, the backend returns or updates state data, and the frontend updates the UI based on the state data.</p> <p></p> <p>In summary, in a frontend-backend separated architecture, state management requires close cooperation between the frontend and backend. Both sides need to reach agreement on API design, data synchronization, authentication, and other aspects to jointly maintain the application's state.</p>"},{"location":"Core%20Concepts.html#2-understanding-state-management","title":"2. Understanding State Management","text":"<p>We've discussed the roles of the frontend and backend in state management. It's clear that regardless of frontend or backend, state management is a core issue in application development. So, what is state? Why is state management so important?</p> <p>In software development, state is everywhere:</p> <ul> <li>On the backend, state could be data in a database, objects in memory, files in a filesystem, etc.</li> <li>On the frontend, state could be the structure of the DOM tree, CSS styles, JavaScript variables, etc.</li> </ul> <p>Broadly speaking, state is a snapshot of a program at a certain moment. It determines the program's current behavior and future direction. Managing state well means managing the program well.</p>"},{"location":"Core%20Concepts.html#state-is-a-snapshot-of-the-system-or-application","title":"State is a \"Snapshot\" of the System or Application","text":"<p>In computer science, we often say \"program = data structure + algorithm\". Data structure, in essence, is a representation of the system's state. The system's state at any moment determines its current behavior and properties. Understanding and managing state is the foundation of controlling the system.</p> <p>Here are a few examples:</p> <ul> <li>The process management in an operating system is essentially managing the state transitions of processes (ready, running, blocked, etc.).</li> <li>Variables in a programming language can be seen as a representation of the program's state. Functional languages emphasize immutable state to reduce the complexity of state management.</li> <li>The ACID properties of databases are meant to ensure the consistency of state before and after transactions.</li> </ul> <p>Or more vividly:</p> <ul> <li>In games, a character's movement, attack, skill release, etc., are all processes of state transition.</li> <li>In social networks, a user's state (like follow, like, comment) determines the display of the information flow.</li> <li>In e-commerce websites, the state of a user's shopping cart, order status, etc., determines the recommendation system and search results.</li> </ul> <p>The primary task of state management is to choose the right data structure to represent the system's state space. A good state representation should be concise, complete, and easy to verify.</p>"},{"location":"Core%20Concepts.html#state-transition-reflects-the-systems-behavior","title":"State Transition Reflects the System's Behavior","text":"<p>If state is a \"snapshot\" of the system, then state transition is the \"script\" of the system's behavior. The dynamic behavior of the system can be seen as the result of a series of state transitions. Each input or event may cause a change in state, thereby changing the system's behavior.</p> <p>The management of state transitions involves several key issues:</p> <ol> <li>Transition Function: Given the current state and input, how to calculate the next state.</li> <li>Consistency: How to ensure the consistency of the final result of concurrent state transitions.</li> <li>Fault Tolerance: How to handle invalid state transitions and prevent the system from entering an erroneous state.</li> </ol> <p>For example:</p> <ul> <li>In a game, a player's attack may cause changes in multiple states, including the attacker's state, the defender's state, the game scene's state, etc.</li> <li>In a social network, a user's like may cause changes in multiple states, including the liker's state, the liked person's state, the recommendation system's state, etc.</li> <li>On an e-commerce website, a user's cart checkout may cause changes in multiple states, including the shopping cart's state, the order's state, the recommendation system's state, etc.</li> </ul> <p>Many engineering problems, such as concurrency control and exception handling, can essentially be boiled down to the management of state transitions. Good state management should ensure:</p> <ol> <li>State Space: All possible states are safe and controllable.</li> <li>State Transition: Any transition satisfies the predefined constraints.</li> <li>State Consistency: All replicas or views eventually converge to a consistent state.</li> </ol> <p>Understanding state management allows us to better understand the essence of blockchain development.</p>"},{"location":"Core%20Concepts.html#3-understanding-blockchain-engineering","title":"3. Understanding Blockchain Engineering","text":"<p>In blockchain application development, the blockchain can replace or partially replace the traditional backend as a distributed database and server. </p> <p></p> <p>The core of blockchain engineering is managing global state in a decentralized network. Here, state can be account balances, smart contract variables, token ownership, etc. Unlike traditional centralized systems, state management in blockchain faces several major challenges.</p>"},{"location":"Core%20Concepts.html#decentralized-storage-of-global-state","title":"Decentralized Storage of Global State","text":"<p>The global state of the blockchain is maintained by all nodes together. Each node saves a complete copy of the state. Although this decentralized storage improves the system's availability and fault tolerance, it also brings several problems:</p> <ol> <li>State Synchronization: How do newly joined nodes obtain the latest state from other nodes?</li> <li>State Validation: How to quickly verify the legitimacy of a state to prevent malicious nodes from injecting erroneous states?</li> <li>State Storage: How to design efficient data structures for synchronizing and verifying state among nodes?</li> </ol> <p>For example, Ethereum uses Merkle Patricia Trees to store state, which can quickly verify state consistency and support state queries by light nodes.</p>"},{"location":"Core%20Concepts.html#consensus-mechanism-for-state-transitions","title":"Consensus Mechanism for State Transitions","text":"<p>State transitions in the blockchain are triggered by transactions. But in a decentralized network, reaching consensus on the order and legitimacy of transactions is a very tricky problem. Consensus mechanisms, such as PoW and PoS, provide a way to reach agreement on state transitions among untrusted nodes.</p> <p>The consensus mechanism needs to solve several problems:</p> <ol> <li>Consistency: How to ensure that honest nodes see a consistent order of state transitions?</li> <li>Liveness: How to ensure that state transitions can be completed within a finite time, without livelock or deadlock?</li> <li>Incentive: How to incentivize nodes to participate in consensus and punish malicious behavior?</li> </ol> <p>For example, Bitcoin's PoW reaches consensus through computing power competition, while Ethereum's PoS chooses block-producing nodes through staking and randomness.</p>"},{"location":"Core%20Concepts.html#state-management-in-smart-contracts","title":"State Management in Smart Contracts","text":"<p>Smart contracts are one of the most powerful features of blockchain. They allow developers to deploy arbitrary state transition logic on the blockchain. From a programming perspective, each contract is like a state machine, managing a set of state variables and performing state transitions based on transaction inputs.</p> <p>State management in smart contracts involves several key issues:</p> <ol> <li>State Representation: How to abstract complex business logic and data structures with state variables?</li> <li>State Transition: How to ensure that each state transition is deterministic and verifiable?</li> <li>Concurrency Control: How to handle concurrent state access and modification to prevent race conditions?</li> </ol> <p>Ethereum's EVM provides a runtime environment for smart contracts. The Solidity programming language supports various state variable types, such as uint, mapping, struct, etc. Contract functions implement state transitions by reading and writing state variables.</p>"},{"location":"Core%20Concepts.html#state-extension-in-layer2-or-rollup-applications","title":"State Extension in Layer2 or Rollup Applications","text":"<p>State storage and transitions in blockchain are all done on Layer1 (mainchain). But due to the limitations of consensus mechanisms and storage capacity, the state throughput of Layer1 is very limited. To extend state capacity, Layer2 solutions emerged.</p> <p>Layer2 solutions, such as state channels and rollups, process state off-chain and only interact with Layer1 at critical moments (such as final state submission), thus greatly improving state throughput. But this also puts higher requirements on state management:</p> <ol> <li>State Sharding: How to split state into multiple Layer2s for parallel processing?</li> <li>Fraud Proofs: How to use cryptographic methods to prove the legitimacy of off-chain state transitions?</li> <li>State Submission: How to securely and efficiently submit Layer2 state to Layer1?</li> </ol> <p>For example, zkRollup uses zero-knowledge proofs to verify off-chain state transitions, while Optimistic Rollup ensures state legitimacy through fraud proofs and challenge periods. zkWasm achieves deterministic and verifiable state transitions by compiling state transition logic into Wasm bytecode and executing it in a zkVM.</p>"},{"location":"Core%20Concepts.html#4-understanding-zero-knowledge-proofs","title":"4. Understanding Zero-Knowledge Proofs","text":"<p>The most significant role of blockchain as a distributed system is verification. We mentioned earlier that zkWasm achieves deterministic and verifiable state transitions, so why do we need verification? What is determinism and verifiability in the context of blockchain, and what role does zero-knowledge proof play in it?</p> <p>Let's start with the essential properties of blockchain. Blockchain is a decentralized network where each node is equal, and there is no centralized authority. This brings the following problems:</p> <ul> <li>How to reach consensus among untrusted nodes? </li> <li>How to ensure that the state transitions seen by each node are consistent and correct?</li> </ul> <p>This requires the introduction of a verification mechanism. When accepting a new state transition (such as a transaction or a new block), each node needs to verify its legitimacy. Only state transitions that pass verification can be added to the blockchain and become part of the global consensus.</p> <p>To achieve reliable verification, determinism and verifiability are needed:</p> <ul> <li> <p>Determinism means that given the same input, the same output is always obtained. In blockchain, determinism means that each node, executing the same state transition logic, will get the same result. This is the premise of reaching consensus. Imagine if the result of a state transition is non-deterministic (for example, dependent on the execution environment or random numbers), different nodes might get different states, breaking the consensus.</p> </li> <li> <p>Verifiability means that the correctness of a state transition can be efficiently verified. In blockchain, verifiability means that any node can quickly check whether a state transition is legal without redoing all the computations. Imagine if verifying a state transition requires replaying the entire computation process, the cost of verification would be as high as generating the state transition, which is unacceptable in computationally intensive situations.</p> </li> </ul> <p>Traditional blockchains (like Bitcoin and Ethereum) achieve determinism by replaying every transaction on each node, and achieve verifiability through a hash-linked block structure. But this method is less efficient, especially when the state transition logic is complex.</p> <p>This is where zero-knowledge proofs come into play. Zero-knowledge proofs are a cryptographic technique that can prove a statement is correct without revealing any information. In blockchain, zero-knowledge proofs can be used to prove that a state transition is legal without revealing the specific input data and intermediate states. More Information about Zero-Knowledge Proofs can be found here or Later in Supplemental Resources.</p> <p>Zero-knowledge proofs provide a more efficient way to implement determinism and verifiability:</p> <ul> <li> <p>For determinism, zero-knowledge proofs require the state transition logic to be deterministic (like zkWasm using a deterministic Wasm subset) to generate proofs.</p> </li> <li> <p>For verifiability, zero-knowledge proofs allow the prover to generate a succinct proof proving the correctness of the state transition, and the verifier only needs to check this proof without redoing the computation. This greatly reduces the cost of verification.</p> </li> </ul> <p>Here's an example. Suppose there is a complex state transition that requires 1,000,000 steps of computation. In a traditional blockchain, each node would need to replay these 1,000,000 steps to verify the result. But with zero-knowledge proofs, the prover only needs to do the computation once to generate a proof, and the verifier might only need to do 100 steps of computation to verify this proof.</p> <p>In addition to efficiency, zero-knowledge proofs bring another important property: privacy. Since the proving process does not reveal input data and intermediate states, zero-knowledge proofs allow verifying the correctness of a computation result without disclosing the original data. This is very important for privacy-sensitive application scenarios (like finance and healthcare).</p>"},{"location":"Core%20Concepts.html#supplemental-resources","title":"Supplemental Resources","text":"<ul> <li>Zero-Knowledge Mastery: A comprehensive guide to zero-knowledge proofs.</li> <li>zkhack: zkhack is a hub for zk learning and building. It hosts virtual events and advanced puzzle competitions, as well as produces educational content and runs study groups. Its goal is to explore and explain key concepts and tools and get you onboarded into zk.</li> <li>zksummit: The annual zkSummit conference, an important event in the zero-knowledge proof community. The conference brings together the best thinkers and builders to discuss the latest in zero knowledge research, zk use-cases, cryptographic primitives, privacy and maths. </li> <li>progcrypto: The Programmable Cryptography Conference is a 2-day event, organized by 0xPARC and PSE, which brings together researchers, developers, and community members focused on next-generation cryptography and its applications. Topics include new research developments in applied cryptography, infrastructure for tools like zkSNARKs and MPC, and applications of these new cryptographic primitives for areas such as digital identity or financial privacy.</li> </ul> <p>Next, we will introduce the core concepts and fundamentals of zkWasm.</p>"},{"location":"Design%20Application%20as%20State%20Machine.html","title":"Designing a Game Application as a State Machine: A Beginner's Guide","text":""},{"location":"Design%20Application%20as%20State%20Machine.html#introduction-to-state-machines","title":"Introduction to State Machines","text":"<p>A state machine is like a flowchart of your game's behavior. Imagine you're creating a simple adventure game - at any moment, your character could be in different situations: exploring, fighting, talking to NPCs, or managing inventory. Each of these situations is a \"state\", and the rules for moving between them are \"transitions\".</p>"},{"location":"Design%20Application%20as%20State%20Machine.html#why-use-state-machines","title":"Why Use State Machines?","text":"<p>For beginners, state machines offer several advantages:</p> <ol> <li>Clear Organization: Your game logic becomes easier to understand and debug</li> <li>Predictable Behavior: You always know exactly what can happen next</li> <li>Easy to Expand: Adding new features becomes more structured</li> <li>Better Testing: Each state can be tested independently</li> </ol>"},{"location":"Design%20Application%20as%20State%20Machine.html#understanding-game-states-through-examples","title":"Understanding Game States Through Examples","text":""},{"location":"Design%20Application%20as%20State%20Machine.html#example-1-a-simple-rpg-character","title":"Example 1: A Simple RPG Character","text":"<p>Let's start with a basic character state system:</p> <pre><code>// Basic character states\nenum CharacterState {\n    Idle,\n    Walking,\n    Running,\n    Jumping,\n    Attacking,\n    TakingDamage,\n}\n\n// Character data structure\nstruct Character {\n    state: CharacterState,\n    position: Position,\n    health: u32,\n    stamina: u32,\n    inventory: Vec&lt;Item&gt;,\n}\n\n// Position in 2D space\nstruct Position {\n    x: f32,\n    y: f32,\n}\n\n// Game item\nstruct Item {\n    id: u32,\n    name: String,\n    weight: u32,\n}\n</code></pre>"},{"location":"Design%20Application%20as%20State%20Machine.html#example-2-turn-based-battle-system","title":"Example 2: Turn-Based Battle System","text":"<p>Here's how we might structure a turn-based battle system:</p> <pre><code>enum BattleState {\n    BattleStart,\n    PlayerTurn,\n    EnemyTurn,\n    Victory,\n    Defeat,\n}\n\nstruct BattleSystem {\n    current_state: BattleState,\n    player: Fighter,\n    enemy: Fighter,\n    turn_count: u32,\n}\n\nstruct Fighter {\n    health: u32,\n    attack: u32,\n    defense: u32,\n    special_moves: Vec&lt;SpecialMove&gt;,\n}\n</code></pre>"},{"location":"Design%20Application%20as%20State%20Machine.html#state-transitions-the-heart-of-game-logic","title":"State Transitions: The Heart of Game Logic","text":""},{"location":"Design%20Application%20as%20State%20Machine.html#understanding-states","title":"Understanding States","text":"<p>Let's visualize how states flow in a simple game:</p> <pre><code>stateDiagram-v2\n    MainMenu --&gt; GamePlaying\n    GamePlaying --&gt; GamePaused\n    GamePlaying --&gt; BattleMode\n    BattleMode --&gt; GamePlaying\n    GamePlaying --&gt; GameOver\n    GamePaused --&gt; GamePlaying\n    GameOver --&gt; MainMenu</code></pre> <p>Except for the game itself, there are many in-game states that control the game flow. These states are the heart of your game logic, and they determine how your game behaves. Basically, there are two kinds of state you can implement in your game:</p> <ol> <li>Static States: These states are fixed and cannot be changed. For example, the main menu, game over screen, or game paused state.</li> <li>Dynamic States: These states can be changed based on user input or game events. For example, the game playing state, battle mode state, or inventory state.</li> </ol> <p>And those states can be divided into two categories:</p> <ol> <li>Global States: These states control the flow of the game, such as the main menu, game over screen, or game paused state, and can be accessed from anywhere in the game.</li> <li>Local States: These states are related to a specific aspect of the game, such as the game playing state, battle mode state, or inventory state, and can only be accessed within the specific context of the game.</li> </ol>"},{"location":"Design%20Application%20as%20State%20Machine.html#state-flow","title":"State Flow","text":"<p>Let's visualize how states flow in a turn-based battle system as example 2:</p> <pre><code>stateDiagram-v2\n    [*] --&gt; BattleStart\n\n    BattleStart --&gt; PlayerTurn : Initialize Battle\n\n    PlayerTurn --&gt; EnemyTurn : Player Action Complete\n    PlayerTurn --&gt; Victory : Enemy HP &lt;= 0\n    PlayerTurn --&gt; Defeat : Player HP &lt;= 0\n\n    EnemyTurn --&gt; PlayerTurn : Enemy Action Complete\n    EnemyTurn --&gt; Victory : Enemy HP &lt;= 0\n    EnemyTurn --&gt; Defeat : Player HP &lt;= 0\n\n    Victory --&gt; [*] : Battle End\n    Defeat --&gt; [*] : Battle End\n\n    note right of BattleStart\n        Setup initial battle conditions:\n        - Load fighter stats\n        - Initialize turn counter\n    end note\n\n    note right of PlayerTurn\n        Player action options:\n        - Basic attack\n        - Special moves\n        - Use items\n    end note\n\n    note right of EnemyTurn\n        Enemy AI processing:\n        - Choose attack pattern\n        - Execute action\n    end note</code></pre>"},{"location":"Design%20Application%20as%20State%20Machine.html#1-battlestart","title":"1. BattleStart","text":"<p>Initial state when combat begins.</p> <p>Entry Actions</p> <ul> <li>Initialize player and enemy Fighter structures</li> <li>Set initial health, attack, and defense values</li> <li>Load special moves into Vec <li>Set turn_count to 0</li> <p>Exit Conditions</p> <ul> <li>Battle initialization complete</li> </ul> <p>Transitions To</p> <ul> <li>PlayerTurn (automatic after initialization)</li> </ul>"},{"location":"Design%20Application%20as%20State%20Machine.html#2-playerturn","title":"2. PlayerTurn","text":"<p>Player's action phase.</p> <p>Entry Actions</p> <ul> <li>Increment turn_count</li> <li>Display player options</li> <li>Enable player input</li> </ul> <p>Available Actions</p> <ul> <li>Basic attack: damage = player.attack - enemy.defense</li> <li>Special moves: custom effects from special_moves Vec</li> </ul> <p>Exit Conditions</p> <ul> <li>Player completes action</li> <li>Health check after action</li> </ul> <p>Transitions To</p> <ul> <li>EnemyTurn (if enemy alive)</li> <li>Victory (if enemy HP &lt;= 0)</li> <li>Defeat (if player HP &lt;= 0)</li> </ul>"},{"location":"Design%20Application%20as%20State%20Machine.html#3-enemyturn","title":"3. EnemyTurn","text":"<p>Enemy's action phase.</p> <p>Entry Actions</p> <ul> <li>Calculate enemy NPC decision </li> <li>Display enemy action animation </li> </ul> <p>NPC Algorithm Processing</p> <ul> <li>Choose between basic attack and special moves</li> <li>Target selection (in case of multiple targets)</li> </ul> <p>Exit Conditions</p> <ul> <li>Enemy completes action</li> <li>Health check after action</li> </ul> <p>Transitions To</p> <ul> <li>PlayerTurn (if player alive)</li> <li>Victory (if enemy HP &lt;= 0)</li> <li>Defeat (if player HP &lt;= 0)</li> </ul>"},{"location":"Design%20Application%20as%20State%20Machine.html#4-victory","title":"4. Victory","text":"<p>Battle won state.</p> <p>Entry Actions</p> <ul> <li>Play victory animation</li> <li>Calculate rewards</li> <li>Update player progress</li> </ul> <p>Exit Conditions</p> <ul> <li>Victory sequence complete</li> </ul> <p>Transitions To</p> <ul> <li>[End State]</li> </ul>"},{"location":"Design%20Application%20as%20State%20Machine.html#5-defeat","title":"5. Defeat","text":"<p>Battle lost state.</p> <p>Entry Actions</p> <ul> <li>Play defeat animation</li> <li>Save game statistics</li> <li>Prepare retry options</li> </ul> <p>Exit Conditions</p> <ul> <li>Defeat sequence complete</li> </ul> <p>Transitions To</p> <ul> <li>[End State]</li> </ul>"},{"location":"Design%20Application%20as%20State%20Machine.html#common-patterns-and-best-practices","title":"Common Patterns and Best Practices","text":""},{"location":"Design%20Application%20as%20State%20Machine.html#1-state-initialization","title":"1. State Initialization","text":"<p>Always initialize your game with a clear starting state:</p> <pre><code>impl GameState {\n    fn new() -&gt; Self {\n        Self {\n            current_scene: SceneType::MainMenu,\n            player: Player::new_game(),\n            game_time: GameTime::default(),\n            battle_state: None,\n            dialogue_state: None,\n            inventory_state: None,\n        }\n    }\n}\n</code></pre>"},{"location":"Design%20Application%20as%20State%20Machine.html#2-state-validation","title":"2. State Validation","text":"<p>Always validate state transitions:</p> <pre><code>fn validate_transition(&amp;self, new_state: &amp;GameState) -&gt; Result&lt;(), String&gt; {\n    // Check if transition is allowed\n    if !self.is_valid_transition(new_state) {\n        return Err(\"Invalid state transition\".to_string());\n    }\n\n    // Validate game rules\n    if !self.validate_game_rules(new_state) {\n        return Err(\"Game rules violated\".to_string());\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"Design%20Application%20as%20State%20Machine.html#3-error-handling","title":"3. Error Handling","text":"<p>Use proper error handling for state transitions:</p> <pre><code>enum GameError {\n    InvalidState(String),\n    SaveError(String),\n    LoadError(String),\n}\n\ntype GameResult&lt;T&gt; = Result&lt;T, GameError&gt;;\n</code></pre>"},{"location":"Design%20Application%20as%20State%20Machine.html#debugging-and-testing","title":"Debugging and Testing","text":""},{"location":"Design%20Application%20as%20State%20Machine.html#1-state-logging","title":"1. State Logging","text":"<p>Implement logging for state transitions use zkWasm SDK:</p> <pre><code>fn log_state_transition(&amp;self, old_state: &amp;GameState, new_state: &amp;GameState) {\n    zkwasm_rust_sdk::dbg!(\"State Transition:\");\n    zkwasm_rust_sdk::dbg!(\"  From: {:?}\", old_state.current_scene);\n    zkwasm_rust_sdk::dbg!(\"  To: {:?}\", new_state.current_scene);\n    zkwasm_rust_sdk::dbg!(\"  Player Previous Health: {:?}\", \n        old_state.player.health\n    );\n    zkwasm_rust_sdk::dbg!(\"  Player Current Health: {:?}\", \n        new_state.player.health\n    );\n}\n</code></pre>"},{"location":"Design%20Application%20as%20State%20Machine.html#2-state-testing","title":"2. State Testing","text":"<p>Write tests for your state machine:</p> <pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_battle_transition() {\n        let mut game = GameState::new();\n        game.start_battle(Enemy::new());\n\n        assert_eq!(game.current_scene, SceneType::Battle);\n        assert!(game.battle_state.is_some());\n    }\n}\n</code></pre> <p>You can also test state transitions based on your RPC calls, for example, in the helloworld rollup we can find a test file which you can modify to test the state transition of the zkWasm Mini Rollup Application:</p> <pre><code>import { Player } from \"./api.js\";\nimport assert from \"assert\";\nlet account = \"1234\";\nlet player = new Player(account, \"http://localhost:3000\");\nasync function main() {\n    let state = await player.getState();\n    console.log(state);\n    console.log(\"register\");\n    await player.register();\n    let pre_counter = state.player.data.counter;\n    console.log(pre_counter);\n    console.log(\"inc counter\");\n    state = await player.incCounter();\n    let post_counter = state.player.data.counter;\n    console.log(post_counter);\n    assert(post_counter == pre_counter + 1);\n}\nmain();\n</code></pre>"},{"location":"Design%20Application%20as%20State%20Machine.html#conclusion","title":"Conclusion","text":"<p>Building a game as a state machine makes your code more:</p> <ul> <li>Organized and easier to understand</li> <li>Reliable and predictable</li> <li>Testable and debuggable</li> <li>Ready for zkWasm integration</li> </ul> <p>Remember to:</p> <ol> <li>Start simple and add complexity gradually</li> <li>Keep your states well-defined and documented</li> <li>Implement proper error handling and validation</li> <li>Test each state and transition thoroughly</li> <li>Consider performance implications of state changes</li> </ol> <p>By following these patterns and practices, you'll create a solid foundation for your application that's both maintainable and extensible.</p>"},{"location":"zkWasm%20Overview.html","title":"zkWasm Overview","text":""},{"location":"zkWasm%20Overview.html#1-introduction-to-zkwasm","title":"1. Introduction to zkWasm","text":"<p>Note</p> <p>This section provides a high-level overview of zkWasm. For more detailed information about zkWasm, please refer to the:</p> <ul> <li>zkWasm Whitepaper</li> <li>zkWasm Book</li> </ul> <p>zkWasm represents a fundamental advancement in the field of trustless computation by combining WebAssembly with zero-knowledge proofs. The system implements a complete WebAssembly virtual machine within zkSNARK circuits, creating a bridge between traditional application development and blockchain technology. This approach allows developers to write programs in familiar languages while gaining the benefits of zero-knowledge proofs without requiring specialized cryptographic knowledge.</p> <p>The core innovation of zkWasm lies in its approach to implementing zero-knowledge proofs. Rather than requiring developers to write programs in specialized circuit-friendly languages, zkWasm applies zero-knowledge proofs at the bytecode level of the virtual machine. This means that any program that can be compiled to WebAssembly can automatically benefit from zero-knowledge capabilities, making the technology accessible to a much broader range of developers and applications. </p> <p>Traditional approaches to implementing zero-knowledge proofs often require developers to work with specialized languages and tools like Pinocchio, TinyRAM, or ZoKrates. This requirement creates a significant barrier to adoption, as developers must learn new programming paradigms and rewrite existing applications. zkWasm eliminates this barrier by operating at the WebAssembly level, allowing developers to work in languages they already know, such as C++, Rust, or AssemblyScript.</p> <p></p> <p>This accessibility extends beyond just the programming language choice. While traditional blockchain development requires extensive knowledge of specific blockchain protocols and smart contract languages, zkWasm further simplifies the blockchain integration process. By operating at the WebAssembly bytecode level, zkWasm automatically handles the generation of zero-knowledge proofs for any application logic like user operations and user interactions. These standardized proofs can be verified on any blockchain platform without requiring developers to write custom smart contracts or complex blockchain-specific protocols for application logic. This approach not only lowers the technical barriers for Web2 developers (as well as their users) entering the Web3 space, but also enables seamless cross-chain compatibility for their applications. </p> <p>Info</p> <p>Compared to the traditional Web3 applications which heavily rely on smart contracts and a specific blockchain system, zkWasm applications are more like Web2 applications, but with the trustless verification capabilities brought by zero-knowledge proofs, it can:</p> <ul> <li>Seamlessly integrate with existing Web2 or Web3 applications</li> <li>Allow developers to focus on business logic and frontend design, without the need to learn much about blockchain or zero-knowledge proofs</li> <li>Allow developers to easily switch between different blockchain platforms if needed</li> <li>Allow developers to easily scale or upgrade their applications</li> <li>Allow gasless interactions and operations (except for the proof verification, deposit and withdrawal which is required when manipulating the onchain assets) for application users</li> </ul>"},{"location":"zkWasm%20Overview.html#2-the-state-machine-foundation","title":"2. The State Machine Foundation","text":"<p>At its core, zkWasm operates as a state machine that processes WebAssembly bytecode while generating proofs of correct execution. The state machine takes as input a tuple consisting of several key components that together define the program and its execution environment. This tuple, represented as (I(C,H), E, IO), contains the WebAssembly executable image I (which includes both code C and initial memory state H), the entry point E, and the input/output firmware IO.</p> <p>The state machine maintains an internal state that captures every aspect of program execution. This state, represented as a tuple (iaddr, F, M, G, Sp, I, IO), includes the current instruction address (iaddr), the call frame (F), memory state (M), global variables (G), and the execution stack (Sp). Each of these components plays a crucial role in program execution and proof generation.</p> <p>Note</p> <p>Understanding the state machine model is crucial for application development because:</p> <ul> <li>Design the state machine model before starting to write code will help a lot on development efficiency</li> <li>Your application's performance depends on minimizing state transitions</li> <li>Proper state handling is essential for correctness and security of your application</li> <li>Consider using tools to analyze your application's state transitions during development</li> </ul>"},{"location":"zkWasm%20Overview.html#state-representation-and-execution-flow","title":"State Representation and Execution Flow","text":"<p>The instruction address (iaddr) keeps track of the current position in the program, determining which instruction will be executed next. The call frame (F) manages function calls and their context, including a depth field that tracks the nesting level of function calls. This depth tracking is crucial for ensuring that all function calls properly return and maintaining the correct execution context. </p> <p>Memory management in zkWasm is handled through the memory state (M), which represents the linear memory space available to the WebAssembly program. This memory can be read from and written to during program execution, with all operations being tracked and verified through the proof system. Global variables (G) provide a way to maintain state across function calls, while the stack (Sp) handles temporary values and computation results.</p> <p>Program execution proceeds through a series of state transitions, with each transition function taking the current state and producing a new state based on the instruction being executed. These transitions form an execution trace that represents the complete history of program execution. The system ensures that each transition follows the WebAssembly specification and maintains the integrity of the program state.</p> <p>Here's a core state structure in Rust:</p> <pre><code>struct State {\n    iaddr: InstructionAddress,  // Current instruction address\n    F: CallFrame,               // Call frame with depth\n    M: MemoryState,            // Memory state\n    G: GlobalVariables,        // Global variables\n    Sp: Stack,                 // Execution stack\n    I: WasmImage,              // WASM executable image\n    IO: IOFirmware            // Input/Output handling\n}\n</code></pre> <p>State transitions and execution can be defined as:</p> <pre><code>type StateTransition = fn(State) -&gt; State;\n\nstruct ExecutionTrace {\n    transitions: Vec&lt;StateTransition&gt;,\n    initial_state: State,\n}\n</code></pre> <p>Let's examine a concrete example of how state transitions work in practice:</p> <pre><code>#[no_mangle]\npub extern \"C\" fn add(x: i32, y: i32) -&gt; i32 {\n    x + y\n}\n</code></pre> <p>This simple addition function generates several state transitions under the hood. Here's what happens:</p> <pre><code>let transitions = vec![\n    // Load first parameter\n    |s| State { \n        stack: s.stack.push(s.memory[s.iaddr + 1]),\n        iaddr: s.iaddr + 1,\n        ..s\n    },\n    // Load second parameter\n    |s| State {\n        stack: s.stack.push(s.memory[s.iaddr + 1]),\n        iaddr: s.iaddr + 1,\n        ..s\n    },\n    // Perform addition\n    |s| {\n        let (stack, y) = s.stack.pop();\n        let (stack, x) = stack.pop();\n        State {\n            stack: stack.push(x + y),\n            iaddr: s.iaddr + 1,\n            ..s\n        }\n    }\n];\n</code></pre> <p>Each transition represents a specific operation in the WebAssembly execution:</p> <ol> <li>The first transition loads parameter x from memory onto the stack</li> <li>The second transition loads parameter y</li> <li>The final transition pops both values, adds them, and pushes the result</li> </ol> <p>The validity of an execution trace is verified as follows:</p> <pre><code>impl ExecutionTrace {\n    fn is_valid(&amp;self) -&gt; bool {\n        let mut current_state = self.initial_state;\n\n        // Verify each transition\n        for transition in &amp;self.transitions {\n            current_state = transition(current_state);\n\n            // Verify transition follows WASM semantics\n            if !verify_semantics(current_state) {\n                return false;\n            }\n        }\n\n        // Verify final state\n        current_state.call_frame.depth == 0\n    }\n}\n</code></pre>"},{"location":"zkWasm%20Overview.html#3-host-builtin-functions","title":"3. Host (Builtin) Functions","text":"<p>Besides the WebAssembly instructions, zkWasm also provides a set of host functions that are not defined in the WebAssembly module itself but are provided by the environment in which the WebAssembly code is executed. These functions are crucial for WebAssembly modules to interact with the outside world, as WASM on its own is quite sandboxed and limited in what it can do directly.</p> <p>Here are some key points about WASM host functions:</p> <ul> <li>Interaction with the Environment: WASM is designed to be a low-level, portable bytecode, which runs in a sandboxed environment. By itself, it doesn't have direct access to the system's resources like file systems, network, or the DOM in web browsers. Host functions serve as the bridge between the WASM code and these external resources.</li> <li>Provided by the Host Environment: The host environment (which could be a web browser, a server-side platform like Node.js, or any other system that supports running WebAssembly) defines and provides these host functions. For instance, in a web browser, the host functions might allow interactions with web APIs.</li> <li>Imported into WASM Modules: WASM modules import these host functions and use them as if they were part of the module. This import/export mechanism is part of the WASM design, allowing for modular code and separation of concerns.</li> <li>Custom Functionality: Host functions can be used to provide custom functionality to WASM modules that is not available in the standard WASM instruction set. This can include anything from accessing the file system to performing complex computations that are more efficiently done in the host language (like JavaScript in the case of web browsers).</li> </ul> <p>In the zkWasm system, a wide range of pre-defined host functions are provided to make it easier to build complex applications. These host functions are divided into three main categories:</p> <ul> <li>I/O related host functions: These functions handle the input and output operations in zkWasm. They provide ways for reading both public and private inputs, keeping track of the current position in the input stream, and outputting results. The difference between public and private inputs is very important for zero-knowledge applications.</li> <li>Merkle tree related host functions: zkWasm includes a Merkle tree implementation for efficiently verifying large data structures. The Merkle tree host functions include setting the root, specifying leaf addresses, updating and retrieving values, and getting the root hash. These functions follow a specific set of rules to ensure consistency and verifiability.</li> <li>Cryptographic operation related host functions: zkWasm implements advanced cryptographic operations, particularly the Poseidon signature scheme, which works well with zero-knowledge proofs. The signature host functions use elliptic curve cryptography (through the BabyJubjub curve) and involve multi-scalar multiplication for verification. These functions provide a secure and efficient way to perform cryptographic operations within the zkWasm environment.</li> </ul> <p>Note</p> <p>When developing zkWasm applications:</p> <ul> <li>Use host functions for external interactions and cryptographic operations (like user operations and signature)</li> <li>Carefully manage the distinction between public and private inputs</li> <li>Leverage the Merkle tree functions for efficient data structure storage, retrieval, and verification, because in zkWasm, we implement Merkle tree as Database Service.</li> <li>Design your application architecture around these built-in capabilities rather than implementing custom solutions.    </li> </ul>"},{"location":"zkWasm%20Overview.html#inputoutput-system-implementation","title":"Input/Output System Implementation","text":"<p>The input/output system in zkWasm provides a mechanism for handling both public and private data. The system centers around the zkmain function, which serves as the entry point for all zkWasm applications. This function has the signature zkmain(void): (void), but can interact with the outside world through specialized host functions.</p> <p>zkWasm distinguishes between public and private inputs through its input functions:</p> <ul> <li><code>zkwasm_input(1)</code> reads public inputs (instances) that will be visible in the proof. </li> <li><code>zkwasm_input(0)</code> handles private inputs (witnesses) that should remain confidential. </li> </ul> <p>This distinction is crucial for zero-knowledge applications, where some data must remain private while still proving computations were performed correctly.</p> <p>The system maintains an internal cursor that tracks the current position in the input stream. When reading inputs, the system takes the value at the current cursor position, places it on top of the execution stack, and advances the cursor. This mechanism ensures orderly processing of inputs while maintaining the distinction between public and private data.</p>"},{"location":"zkWasm%20Overview.html#merkle-tree-integration","title":"Merkle Tree Integration","text":"<p>An integral part of the I/O system is the Merkle tree implementation, which provides efficient verification of large data structures. zkWasm includes a built-in Merkle tree with a depth of 32 levels, supporting indices from 0 to 2^32-1. </p> <p>The Merkle tree API provides the following functions:</p> <pre><code>extern \"C\" {\n    pub fn merkle_setroot(x: u64);\n    pub fn merkle_address(x: u64);\n    pub fn merkle_set(x: u64);\n    pub fn merkle_get() -&gt; u64;\n    pub fn merkle_getroot() -&gt; u64;\n}\n</code></pre> <ul> <li><code>merkle_setroot</code>: Sets the Merkle root to establish the context.</li> <li><code>merkle_address</code>: Specifies the leaf address for the operation.</li> <li><code>merkle_set</code>: Updates the value at the currently selected address.</li> <li><code>merkle_get</code>: Retrieves the value at the currently selected address, along with a proof of inclusion.</li> <li><code>merkle_getroot</code>: Returns the current root hash, which represents the entire state of the tree.</li> </ul> <p>The Merkle tree operations follow a specific protocol to ensure consistency and verifiability. Here's an example:</p> <pre><code>#[no_mangle]\npub extern \"C\" fn merkle_tree_example() {\n    unsafe {\n        // Set up Merkle tree state\n        let root = [1u64, 2u64, 3u64, 4u64];  // Example root\n\n        // Set root for operations\n        for (i, &amp;value) in root.iter().enumerate() {\n            merkle_setroot(value);\n        }\n\n        // Query leaf at index 0\n        merkle_address(0);\n        let value = merkle_get();\n\n        // Update leaf value\n        merkle_set(value + 1);\n\n        // Get new root after modification\n        let new_root = merkle_getroot();\n        zkwasm_output(new_root);\n    }\n}\n</code></pre> <p>This example demonstrates a complete Merkle tree operation cycle:</p> <ol> <li>First, it initializes the tree with a known root</li> <li>Then it queries a specific leaf value</li> <li>Updates that value</li> <li>Finally retrieves the new root hash that reflects the change</li> </ol> <p>The Merkle tree implementation supports efficient verification of data integrity. Here's an example of how verification works:</p> <pre><code>pub struct MerkleProof {\n    leaf_value: u64,\n    path: Vec&lt;(u64, bool)&gt;,  // (hash, is_left)\n    root: u64,\n}\n\nimpl MerkleProof {\n    pub fn verify(&amp;self) -&gt; bool {\n        let mut current_hash = self.leaf_value;\n\n        // Traverse the path from leaf to root\n        for &amp;(sibling_hash, is_left) in &amp;self.path {\n            current_hash = if is_left {\n                hash_pair(sibling_hash, current_hash)\n            } else {\n                hash_pair(current_hash, sibling_hash)\n            };\n        }\n\n        current_hash == self.root\n    }\n}\n</code></pre> <p>This verification process ensures that a particular leaf value is indeed part of the Merkle tree with the given root. The path provides the necessary sibling hashes to reconstruct the root hash.</p>"},{"location":"zkWasm%20Overview.html#signature-scheme","title":"Signature Scheme","text":"<p>zkWasm implements the Poseidon signature scheme, which leverages elliptic curve cryptography through the BabyJubjub curve, providing efficient verification while maintaining security.</p> <p>The signature consists of two components: - sig_r: A point on the BabyJubjub elliptic curve - sig_s: A scalar value used in the signature verification equation</p> <pre><code>struct JubjubSignature {\n    sig_r: BabyJubjubPoint,\n    sig_s: Scalar,\n}\n</code></pre> <p>This verification process involves several steps:</p> <ol> <li>It performs a multi-scalar multiplication (msm) combining:</li> <li>The public key with the message hash</li> <li>The signature's R point with the constant ONE</li> <li>The negative of the base point with the s value</li> <li>The result should be the point (0, 1) if the signature is valid</li> </ol> <pre><code>impl JubjubSignature {\n    pub fn verify(&amp;self, pk: &amp;BabyJubjubPoint, msghash: &amp;[u64; 4]) {\n        unsafe {\n            let r = BabyJubjubPoint::msm(&amp;[\n                (pk, msghash),\n                (&amp;self.sig_r, &amp;ONE.0),\n                (&amp;NEG_BASE, &amp;self.sig_s),\n            ]);\n\n            require(r.x.is_zero() &amp;&amp; r.y == ONE);\n        }\n    }\n}\n</code></pre> <p>Let's look at how this is used in practice:</p> <pre><code>#[no_mangle]\npub extern \"C\" fn verify_signature_example() {\n    unsafe {\n        // Read signature components from input\n        let sig_r_x = zkwasm_input(0);\n        let sig_r_y = zkwasm_input(0);\n        let sig_s = zkwasm_input(0);\n\n        // Read public key\n        let pk_x = zkwasm_input(1);\n        let pk_y = zkwasm_input(1);\n\n        // Read message hash\n        let msg_hash = [\n            zkwasm_input(1),\n            zkwasm_input(1),\n            zkwasm_input(1),\n            zkwasm_input(1),\n        ];\n\n        // Construct signature object\n        let signature = JubjubSignature {\n            sig_r: BabyJubjubPoint::new(sig_r_x, sig_r_y),\n            sig_s: Scalar::new(sig_s),\n        };\n\n        // Verify signature\n        let pk = BabyJubjubPoint::new(pk_x, pk_y);\n        signature.verify(&amp;pk, &amp;msg_hash);\n\n        // Output verification result\n        zkwasm_output(1);  // Success if we reach here\n    }\n}\n</code></pre>"},{"location":"zkWasm%20Overview.html#4-proof-generation-and-verification","title":"4. Proof Generation and Verification","text":"<p>The proof generation system in zkWasm handles the complexity of real-world applications through a segmentation approach. This is necessary because execution traces can contain millions of instructions, far exceeding what can be proved in a single circuit. The system breaks down long execution traces into manageable segments, each with its own proof, which are then combined into a complete verification of the entire execution.</p> <p>Note</p> <p>To optimize proof generation in your applications:</p> <ul> <li>Design with proof segmentation in mind</li> <li>Batch related operations to minimize segment boundaries</li> <li>Implement proper error handling that doesn't leak private information</li> <li>Consider the trade-offs between segment size and proof generation time</li> </ul> <p>Each execution segment maintains its own starting state, sequence of instructions, ending state, and proof of correct execution:</p> <pre><code>struct ExecutionSegment {\n    start_state: State,\n    instructions: Vec&lt;Instruction&gt;,\n    end_state: State,\n    proof: SegmentProof,\n}\n</code></pre> <p>This structure represents a single segment of execution. Let's understand each component:</p> <ul> <li>start_state: Contains the complete state at the beginning of the segment</li> <li>instructions: The list of WebAssembly instructions executed in this segment</li> <li>end_state: The resulting state after executing all instructions</li> <li>proof: The zero-knowledge proof for this segment's execution</li> </ul> <p>The proof generation system uses these segments as building blocks. Here's how a segment is processed:</p> <pre><code>impl ExecutionSegment {\n    fn process_segment(&amp;mut self) -&gt; Result&lt;(), Error&gt; {\n        let mut current_state = self.start_state.clone();\n\n        // Execute each instruction and track state changes\n        for instruction in &amp;self.instructions {\n            // Execute instruction\n            current_state = execute_instruction(current_state, instruction)?;\n\n            // Verify state transition\n            verify_state_transition(&amp;current_state)?;\n\n            // Generate constraints for the proof\n            self.proof.add_constraints(current_state.clone())?;\n        }\n\n        // Verify final state matches expected end state\n        if current_state != self.end_state {\n            return Err(Error::StateMismatch);\n        }\n\n        Ok(())\n    }\n}\n</code></pre> <p>This implementation shows how each segment maintains execution integrity:</p> <ol> <li>It starts from the initial state</li> <li>Processes each instruction sequentially</li> <li>Verifies state transitions</li> <li>Generates proof constraints</li> <li>Ensures the final state matches expectations</li> </ol> <p>Additionally, segments are grouped into bundles for efficient management:</p> <pre><code>struct BundleExecution {\n    segments: Vec&lt;ExecutionSegment&gt;,\n    continuation_proof: ContinuationProof,\n}\n</code></pre> <p>Segments are grouped into bundles for efficient management:</p> <pre><code>struct BundleExecution {\n    segments: Vec&lt;ExecutionSegment&gt;,\n    continuation_proof: ContinuationProof,\n}\n\nimpl BundleExecution {\n    fn new() -&gt; Self {\n        BundleExecution {\n            segments: Vec::new(),\n            continuation_proof: ContinuationProof::default(),\n        }\n    }\n\n    fn add_segment(&amp;mut self, segment: ExecutionSegment) -&gt; Result&lt;(), Error&gt; {\n        // Verify segment connects with previous one\n        if let Some(last_segment) = self.segments.last() {\n            if last_segment.end_state != segment.start_state {\n                return Err(Error::SegmentMismatch);\n            }\n        }\n\n        // Process and add segment\n        segment.process_segment()?;\n        self.segments.push(segment);\n\n        Ok(())\n    }\n\n    fn finalize(&amp;mut self) -&gt; Result&lt;(), Error&gt; {\n        // Generate continuation proof\n        self.continuation_proof = ContinuationProof::connect_segments(&amp;self.segments)?;\n\n        // Verify bundle consistency\n        self.verify_bundle_integrity()?;\n\n        Ok(())\n    }\n}\n</code></pre> <p>The system ensures that segments connect properly, with the ending state of one segment matching the starting state of the next. This segmentation allows for efficient proof generation while maintaining the security and correctness of the overall system.</p> <p>zkWasm generates three types of proofs that work together to verify program execution:</p> <ol> <li>Guest Circuit Proofs: Verify the correct execution of WebAssembly instructions within a segment. These proofs ensure that each instruction follows the WebAssembly specification.</li> <li>Host Circuit Proofs: Validate external function calls and their results. These proofs verify that interactions with the environment (through host functions) are correct.</li> <li>Aggregation Circuit Proofs: Combine multiple proofs into a single, verifiable proof. This includes connecting segment proofs and ensuring the overall execution is valid.</li> </ol> <p>The proof generation process begins with individual segment proofs, creates continuation proofs to connect the segments, and finally combines everything into a single, verifiable proof. This hierarchical approach allows zkWasm to handle complex applications while maintaining efficient proof generation and verification.</p>"},{"location":"zkWasm%20Overview.html#5-development-process-and-best-practices","title":"5. Development Process and Best Practices","text":"<p>Developing applications for zkWasm requires careful attention to state management and performance optimization. State changes should be minimized when possible, as each state transition must be proved in the zero-knowledge system. Related operations should be batched together when possible to reduce the number of state transitions and improve proof generation efficiency.</p> <p>Besides, memory management plays a crucial role in zkWasm application performance. The linear memory model of WebAssembly must be used efficiently, with careful attention paid to memory layout and access patterns. Global variables should be used judiciously, as they affect the state that must be tracked and proved.</p> <p>Error handling in zkWasm applications requires special consideration due to the zero-knowledge context. Errors must be handled in a way that doesn't leak information about private data while still providing useful feedback about what went wrong. This often involves careful design of error conditions and appropriate use of public and private inputs. We will cover more about error handling in practice in the later chapters.</p>"},{"location":"zkWasm%20Overview.html#6-architecture-of-a-zkwasm-rollup-application","title":"6. Architecture of a zkWasm Rollup Application","text":""},{"location":"additional-resources/Frequently%20Asked%20Questions.html","title":"Frequently Asked Questions","text":""},{"location":"additional-resources/Frequently%20Asked%20Questions.html#transaction-types-and-processing","title":"Transaction Types and Processing","text":"<p>Q: There are two types of transactions: ones that modify on-chain state (like withdrawals) and ones that only modify the Merkle tree database. Is there any difference in how the rollup processes these? How do we distinguish which transactions need to be settled on-chain?</p> <p>A: The off-chain processing is actually the same for both types. You can think of the transactions that modify on-chain state as having \"side effects\". The rollup processes them identically, but some transactions will trigger additional on-chain state changes.</p>"},{"location":"additional-resources/Frequently%20Asked%20Questions.html#zkwasm-application-migration-and-upgrades","title":"zkWasm Application Migration and Upgrades","text":"<p>Q: Why don't we need to modify the Verifier contract when upgrading a zkWasm application?</p> <p>A: This is because zkWasm uses image as input to the circuit, and there's an image commitment that checks which image the proof is for. When you upgrade the logic, you don't need to change the circuit because the entire zkWasm virtual machine is written in circuits. This makes the verifier universal and applicable across different versions of your application logic.</p> <p>The image is part of the input, and the commitment mechanism ensures verification of which specific image (application version) the proof corresponds to. This design allows for logic upgrades without requiring changes to the underlying verification infrastructure.</p> <p>Q: In MIGRATE, why do we only get the Merkle root from the contract? How is this sufficient for an upgrade?</p> <p>A: The upgrade mechanism only allows changes to the business logic, not the data structure. Since the data structure remains unchanged, updating the Merkle root is sufficient. The mini-rollup doesn't need to be modified because the underlying data structure remains the same.</p>"},{"location":"additional-resources/Official%20Links.html","title":"Official Links","text":"<p>Welcome to DelphinusLab's official communication channels and resources. Feel free to connect with us through any of the following platforms:</p> Platform Link  Website https://delphinuslab.com/  Tutorials &amp; Resources https://delphinuslab.com/tutorial/learning-resource/  Twitter https://x.com/DelphinusLab  Discord https://discord.com/invite/EhFMmF7S7b  Telegram https://t.me/DelphinusLabOfficial  GitHub https://github.com/DelphinusLab  zkWasm Hub https://zkwasmhub.com/  zkWasm Hub Explorer https://explorer.zkwasmhub.com/ <p>Follow us to stay updated with the latest news and developments!</p>"},{"location":"additional-resources/Project%20Examples.html","title":"Project Examples","text":"<p>Here are some examples of projects that have been built using DelphinusLab's tools and technologies:</p> <ol> <li> <p>Hello World: A simple rollup application that serves as the perfect starting point for beginners. We recommend this as your first project to understand the basics of DelphinusLab's tools and technologies. Follow our quick tutorial to get started.</p> </li> <li> <p>Automata: A comprehensive mining game that demonstrates the implementation of time-driven events. This project showcases how to handle time-based mechanics in zkWasm applications.</p> </li> <li> <p>MemeDisco: An interactive gaming platform that allows users to create and customize their own memes. This project demonstrates the integration of user-generated content within zkWasm.</p> </li> <li> <p>Autocombat: An automatic battle game that implements random number generation. This project showcases how to handle randomness in zkWasm applications while maintaining fairness and transparency.</p> </li> <li> <p>Tower Defence: A classic tower defense game implementation that demonstrates complex game logic and state management using zkWasm technology.</p> </li> </ol>"},{"location":"additional-resources/Project%20Examples.html#getting-started-with-the-projects","title":"Getting Started with the Projects","text":"<p>To run any of these example projects, follow these steps:</p> <ol> <li> <p>Project Setup</p> <ul> <li>Clone the repository of your chosen project</li> <li>Review the project's README.md file for any project-specific requirements</li> <li>Familiarize yourself with the codebase structure</li> </ul> </li> <li> <p>Environment Setup</p> <ul> <li>Install all required dependencies</li> <li>Ensure your development environment meets the system requirements</li> </ul> </li> <li> <p>Build and Run</p> <ul> <li>Follow the same steps as outlined in our quick tutorial</li> <li>Instead of using the template project code, use the code from your chosen example project</li> <li>Pay attention to any project-specific configuration or setup steps mentioned in the project's documentation</li> </ul> </li> </ol> <p>For the best learning experience, we recommend starting with the Hello World project before moving on to more complex examples.</p>"},{"location":"development-guide/Generating%20Random%20Numbers.html","title":"Generating Random Numbers","text":""},{"location":"development-guide/Generating%20Random%20Numbers.html#overview","title":"Overview","text":"<p>Random numbers are essential for many applications, including games, simulations, and secure systems. Generating random numbers in a zkWasm Rollup Application is a bit different from generating random numbers in a traditional Web2 application, it follows an interactive approach to ensure the randomness of the numbers is secure and verifiable. We will use the autocombat Game as an example to demonstrate how to generate random numbers in a zkWasm Rollup Application.</p>"},{"location":"development-guide/Generating%20Random%20Numbers.html#game-autocombat","title":"Game: autocombat","text":"<p>autocombat is a PVE game where players can bet on the outcome of battles between themselves and the enemy (which is controlled by the server admin). And the outcome of a battle is determined by a random number. There are several stages to generate the random number and can be summarized as follows:</p> <p>Timetick 1:</p> <ul> <li>Seed Commitment: The admin generates a random seed and commits to it by storing its hash, commitment = hash(seed), in the game state.</li> </ul> <p>Timetick 2:</p> <ul> <li>Player Signature: The player signs their bet transaction, and their signature is used to generate a random component (SR).</li> <li>Seed Revelation: The admin reveals the seed by submitting it to the server.</li> <li>Verification: The server verifies that the revealed seed is correct by checking that hash(seed) = commitment.</li> <li>Random Number Generation: Then, a random number for the player is generated using the formula seed xor SR. This random number will be used in the next battle.</li> </ul> <p>Remind that timetick is a kind of transaction that generates by the server which can be used to manage or trigger time-related operations and events.</p>"},{"location":"development-guide/Generating%20Random%20Numbers.html#interaction-details","title":"Interaction Details","text":"<p>Let's examine the details of how random numbers are generated by walking through several rounds of game interactions.</p>"},{"location":"development-guide/Generating%20Random%20Numbers.html#first-round-first-timetick-server-initialization-and-commitment-record","title":"First Round, First Timetick (Server Initialization and Commitment Record)","text":"<ol> <li>Server starts timetick without any player bets.</li> <li>In zkwasm ts server, when a timetick transaction is generated, <code>generateRandomSeed()</code> generates a randseed and returns its 64-bit SHA256 commitment, you can refer to the code to see how it works.  And specifically, in <code>generateRandomSeed()</code>:     <pre><code>function randByte() {\n    return Math.floor(Math.random() * 0xff); // generate a random byte between 0 and 255, this is because the randseed is a 64-bit array of bytes\n}\nasync function generateRandomSeed() {\n    let randSeed = [randByte(), randByte(), randByte(), randByte(), randByte(), randByte(), randByte(), randByte()]; // generate a 64-bit randseed\n    let sha = sha256(new Uint8Array(randSeed)); // hash the randseed\n    const mask64 = BigInt(\"0xFFFFFFFFFFFFFFFF\"); // generate a 64-bit mask\n    const shaCommitment = BigInt(sha) &amp; mask64; // mask the sha to 64-bit\n    const randRecord = new modelRand({\n        commitment: shaCommitment.toString(),\n        seed: randSeed,\n    });  // create a new rand record\n    await randRecord.save(); // save the rand record to the database\n    return shaCommitment; // return the commitment\n}\n</code></pre>     The commitment and rand seed are stored in the database and the commitment is returned to the server.</li> <li>Then, <code>application.randSeed()</code> returns 0 (which is the initial value) and assign it to <code>oldSeed</code>. And we assign the 0 to <code>seed</code>:         <pre><code>const oldSeed = application.randSeed(); // get the old seed\nconst seed = 0n; // assign the seed to 0n\n</code></pre></li> <li>Because the oldSeed is 0, we don't need to retrive the rand generated in the previous round (because there is no previous round) so we skip the following code:         <pre><code>if (oldSeed != 0n) {\n    ...\n} // This is skipped\n</code></pre></li> <li> <p>Then, the server signs <code>[0n, seed, rand, 0n]</code> and sends it to the application, the first 0n is the command which indicates <code>timetick</code>, the seed is the oldSeed, the rand is the new commitment, the last 0n just indicates empty:     <pre><code>let signature = sign(new BigUint64Array([0n, seed, rand, 0n]), SERVER_PRI_KEY);\nlet u64array = signature_to_u64array(signature);\napplication.handle_tx(u64array);\n</code></pre>     In <code>sign</code>, we use the server's private key to sign the transaction:     <pre><code>export function sign(cmd: BigUint64Array, prikey: string) {\n    let pkey = PrivateKey.fromString(prikey);\n    ...\n    let H = cmd[0] + (cmd[1] &lt;&lt; 64n) + (cmd[2] &lt;&lt; 128n) + (cmd[3] &lt;&lt; 192n); // convert the command array to a single big number\n    let hbn = new BN(H.toString(10)); // convert the bigint to a BN\n    let S = r.add(pkey.key.mul(new CurveField(hbn))); // sign the command\n    ...\n    const data = {\n        msg: bnToHexLe(hbn), // convert the bigint to a hex string\n        ...\n        sigr: bnToHexLe(S.v), // convert the signature to a hex string\n    };\n    return data;\n}\n</code></pre></p> <p>In signature_to_u64array, we convert the signature to a u64array: <pre><code>function signature_to_u64array(value) {\n    const msg = new LeHexBN(value.msg).toU64Array();\n    ...\n    const sigr = new LeHexBN(value.sigr).toU64Array();\n    let u64array = new BigUint64Array(24);\n    u64array.set(msg);\n    ...\n    u64array.set(sigr, 20);\n    return u64array;\n}\n</code></pre> And you can record that the msg is in the first 4 elements of the u64array, which is 0-3, and the sigr is in the last 4 elements of the u64array, which is 20-23. </p> <p>And in <code>handle_tx</code>: <pre><code>pub fn handle_tx(params: Vec&lt;u64&gt;) -&gt; u32 {\n    let user_address = [params[4], params[5], params[6], params[7]]; // get the user address\n    let command = [params[0], params[1], params[2], params[3]]; // get the command and the parameters, here will be [0n, seed, rand, 0n]\n    let sig_r = [params[20], params[21], params[22], params[23]]; // get the sig_r\n    let transaction = $T::decode(command); // decode the command\n    transaction.process(&amp;user_address, &amp;sig_r) // process the transaction\n}\n    ```\nWe can see that the command is `[0n, seed, rand, 0n]`, and the sig_r is the signature of the command. They are retrived through their positions in the u64array. Remind the Transaction struct is defined in `state.rs` as:\n```rs\npub struct Transaction {\n    pub command: u32,\n    pub data: [u64; 3],\n}\n</code></pre> This matches the command <code>[params[0], params[1], params[2], params[3]]</code>, as the command in Transaction is the first element of the u64array, and the data is the next 3 elements of the u64array. In Transaction implementation, we can call <code>self.command</code> and <code>self.data</code> to get the command and the data.</p> </li> <li> <p>State updates rand_commitment to the new commitment</p> <p>In <code>process</code> function of <code>state.rs</code>, we can see that the rand_commitment is updated to the new commitment in the Timetick transaction through <code>state.rand_commitment = self.data[1];</code>: <pre><code>pub fn process(&amp;self, pid: &amp;[u64; 4], sigr: &amp;[u64; 4]) -&gt; u32 {\n    if self.command == TIMETICK {\n        let state = unsafe { &amp;mut STATE };\n        state.counter += 1;\n        let rand = self.data[0]; // get the new commitment\n        let mut hasher = HASHER.clone();\n        hasher.update(rand.to_le_bytes()); // hash the new commitment\n        let v = hasher.finalize(); // get the hash result\n        let checkseed = u64::from_be_bytes(v[24..32].try_into().unwrap()); // get the checkseed\n        if state.rand_commitment !=0 {\n            unsafe { zkwasm_rust_sdk::require(state.rand_commitment == checkseed) };\n        } // verify the rand, which is skipped here because the rand_commitment is 0 (initial value)\n        state.rand_commitment = self.data[1]; // update the rand_commitment to the new commitment\n        ...\n    }\n    ...\n</code></pre> Now we set the rand_commitment to the new commitment, this is the foundation of the verification of the next round.</p> </li> </ol> <p>Application</p> <p>You may notice that the server calls the application to get the states of the game through <code>application.FUNCTION_NAME()</code>. Typically, these functions are defined in the implementation of the state struct in the state.rs file of the application and actually, they are implementations of zkWasm Rest Server's ABI.</p>"},{"location":"development-guide/Generating%20Random%20Numbers.html#second-round-second-timetick-commitment-verification-and-random-number-generation","title":"Second Round, Second Timetick (Commitment Verification and Random Number Generation)","text":"<ol> <li>Server executes another timetick, just like the first round.</li> <li>Generates new randseed and commitment through <code>let rand = await generateRandomSeed();</code>, now the <code>rand</code> is the new commitment.</li> <li>Retrieves previous rand_commitment: <pre><code>let oldSeed = application.randSeed();\n</code></pre></li> <li>Retrieves previous randseed from database using the commitment as key: <pre><code>if (oldSeed != 0n) {\n    const randRecord = await modelRand.find({\n        commitment: oldSeed.toString(),\n    });\n    seed = randRecord[0].seed.readBigInt64LE();\n}\n</code></pre></li> <li>Signs <code>[0n, previous_randseed, new_commitment, 0n]</code> as the same way as the first round and send it to the application.</li> <li> <p>Verifies hash(previous_randseed) = previous_commitment:</p> <p>In <code>process</code> function of <code>state.rs</code>, we can see that the previously generated randseed, which indicates by the <code>rand</code>, is verified through <code>unsafe {zkwasm_rust_sdk::require(state.rand_commitment == checkseed)};</code>: <pre><code>pub fn process(&amp;self, pid: &amp;[u64; 4], sigr: &amp;[u64; 4]) -&gt; u32 {\n    let state = unsafe { &amp;mut STATE };\n    state.counter += 1;\n    let rand = self.data[0];\n    let mut hasher = HASHER.clone();\n    hasher.update(rand.to_le_bytes());\n    let v = hasher.finalize();\n    let checkseed = u64::from_be_bytes(v[24..32].try_into().unwrap()); // get the commitment of the previous randseed as the same way when the server generates the new commitment\n    if state.rand_commitment !=0 {\n        unsafe { zkwasm_rust_sdk::require(state.rand_commitment == checkseed) };\n    } // verify the rand\n    ...\n}\n</code></pre></p> </li> <li> <p>Updates rand_commitment to new_commitment, this is for the next round's verification of randseed generated in this round:     <pre><code>state.rand_commitment = self.data[1]; // update the rand_commitment to the new commitment\n</code></pre></p> </li> <li> <p>Settles using previous_randseed, after the verification, the previously generated randseed is used to generate the random number for the player:     <pre><code>unsafe { STATE.settle(rand) };\n</code></pre></p> <p>In <code>settle</code> function, we can see that the random number is generated through <code>let final_rand = game.rand ^ rand</code>: <pre><code>pub fn settle(&amp;mut self, rand: u64) {\n    for game in self.games.iter_mut() {\n        let final_rand = game.rand ^ rand;\n        game.settle(final_rand);\n    }\n    self.games = vec![];\n}\n</code></pre> 8. You may notice that we haven't mentioned the <code>game.rand</code> appears in the <code>settle</code> function. This is the Player's random number generated from their signature. Let's see how it works.</p> </li> </ol>"},{"location":"development-guide/Generating%20Random%20Numbers.html#second-round-player-interaction","title":"Second Round (Player Interaction)","text":"<p>This is still the second round, but here we will see how the player's random number is generated.</p> <ol> <li>Player can start to play the game by signing transaction data <code>[command, bet, 0n, 0n]</code> by calling <code>place</code> function of <code>api.js</code>:    <pre><code> async place(bet) {\n     let nonce = await this.getNonce();\n     let processStamp = await this.rpc.sendTransaction(new BigUint64Array([createCommand(nonce, CMD_PLACE, 0n), bet, 0n, 0n]), this.processingKey);\n }\n</code></pre></li> <li> <p>And in the <code>process</code> function of <code>state.rs</code>, we can see that the player's random number is generated through <code>let rand = sigr[0] ^ sigr[1] ^ sigr[2] ^ sigr[3];</code>:    <pre><code> pub fn process(&amp;self, pid: &amp;[u64; 4], sigr: &amp;[u64; 4]) -&gt; u32 {\n     if self.command == PLACE {\n         let rand = sigr[0] ^ sigr[1] ^ sigr[2] ^ sigr[3];\n         self.place(self.data[0], &amp;pid, rand)\n     }\n     ...\n }\n</code></pre>    Remind that the sigr is the signature of the transaction data <code>[command, bet, 0n, 0n]</code>. Therefore, we got the player's random number generated from their signature.</p> </li> <li> <p>Now we take a look at the <code>place</code> function of <code>state.rs</code>, we can see the <code>rand</code> is stored in the game record through <code>let game = Game::new(&amp;player, place, rand);</code>:    <pre><code> pub fn place(&amp;self, place: u64, pkey: &amp;[u64; 4], rand: u64) -&gt; u32 {\n     let mut player = CombatPlayer::get_from_pid(&amp;CombatPlayer::pkey_to_pid(pkey));\n     match player.as_mut() {\n         None =&gt; ERROR_PLAYER_NOT_FOUND,\n         Some(player) =&gt; {\n             if player.data.placed != 0 {\n                 return PLAYER_IN_GAME;\n             } if player.data.power == 0 {\n                 return PLAYER_IS_DEAD;\n             } else {\n                 let game = Game::new(&amp;player, place, rand);\n                 unsafe { STATE.new_game(game) };\n                 player.data.placed = place;\n                 player.store();\n                 return 0\n             }\n         }\n     }\n }\n</code></pre>    Now we can retrieve the player's random number from the game record through <code>let player_rand = game.rand;</code>. And this shall answer the question that how the player's random number is generated and how the final random number is generated in <code>settle</code> function:</p> <pre><code>pub fn settle(&amp;mut self, rand: u64) {\n    for game in self.games.iter_mut() {\n        let final_rand = game.rand ^ rand;\n        game.settle(final_rand);\n    }\n    self.games = vec![];\n}\n</code></pre> </li> </ol>"},{"location":"development-guide/Generating%20Random%20Numbers.html#understanding-the-random-number-generation-mechanism","title":"Understanding the Random Number Generation Mechanism","text":""},{"location":"development-guide/Generating%20Random%20Numbers.html#how-randomness-is-achieved","title":"How Randomness is Achieved","text":"<p>The final random number is generated through XOR operation between two components:</p> <ol> <li>The player's random number (derived from transaction signature)</li> <li>The server admin's random number</li> </ol> <p>This dual-source approach ensures true randomness through several security measures.</p>"},{"location":"development-guide/Generating%20Random%20Numbers.html#server-admins-random-number-security","title":"Server Admin's Random Number Security","text":"<ul> <li>While the admin knows their generated random number, they cannot manipulate it</li> <li>Security is achieved through commitment mechanism:<ul> <li>Admin must commit to the random number before revealing it</li> <li>Commitment (hash) is stored in the game state</li> <li>Later revelation must match the commitment</li> <li>Any attempt to change the number would be detected through hash verification</li> </ul> </li> </ul>"},{"location":"development-guide/Generating%20Random%20Numbers.html#players-random-number-security","title":"Player's Random Number Security","text":"<ul> <li>Players can calculate their own random number from their signature, but cannot predict the final random number since the server admin's random number is only revealed in the next timetick transaction.</li> <li>The player's random number is maintained through:<ul> <li>Transparent signature calculation process and can be verified.</li> <li>Cannot be altered after submission</li> </ul> </li> </ul>"},{"location":"development-guide/Generating%20Random%20Numbers.html#combined-randomness-through-xor","title":"Combined Randomness Through XOR","text":"<ul> <li>The XOR operation between these two sources creates unpredictability</li> <li>Neither party can determine the final random number</li> <li>Even if one party knows their random number component, they cannot predict or manipulate the outcome</li> </ul>"},{"location":"development-guide/Generating%20Random%20Numbers.html#preventing-manipulation-through-timing-timetick","title":"Preventing Manipulation Through Timing (Timetick)","text":"<p>A critical aspect of the system is preventing manipulation through careful timing of operations:</p> <ol> <li> <p>Sequential Submission:</p> <ul> <li>Players submit their random number component (through place operation) before seeing the admin's random number.</li> <li>Admin's random number is only revealed in the next timetick</li> <li>This prevents players from choosing their random number based on known admin values</li> </ul> </li> <li> <p>Settlement Timing:</p> <ul> <li>Settlement cannot occur in the same timetick (Server submits the commitment) as the player's place operation, this is because the server's random number is revealed in the next timetick.</li> <li>Must wait for next timetick when:<ul> <li>Admin reveals the previous commitment's random number</li> <li>New commitment is created for future rounds</li> </ul> </li> </ul> </li> <li> <p>Round Structure:    <pre><code>Round N / Timetick N:\n- Player submits their random component\n- Admin commits to new random number\n\nRound N+1 / Timetick N+1:\n- Admin reveals previous round's random number\n- Settlement occurs using XOR of:\n  - Player's submitted random (from Round N)\n  - Admin's revealed random (committed in Round N-1)\n</code></pre></p> </li> </ol>"},{"location":"development-guide/Implementing%20Time-Driven%20Events.html","title":"Implementing Time-Driven Events","text":""},{"location":"development-guide/Implementing%20Time-Driven%20Events.html#overview","title":"Overview","text":"<p>Time-Driven Events are events that are triggered by the passage of time. For example, in a farming game, crops growing over time and eventually becoming harvestable would be a time-driven event.</p> <p>These events can affect the state of a minirollup application. Using the farming game example, crop growth would be represented by changes in the crop's state, which could then trigger other events.</p> <p>Traditional blockchain systems don't natively support time-driven events since blockchains cannot autonomously trigger state changes. However, we can simulate time-driven events using an external account controlled by an off-chain service.</p> <p>In zkWasm, we have a server-side sequencer that manages the transaction queue. This sequencer can generate timetick transactions to trigger time-driven events (see the Sequencer section in the server documentation). This provides native support for time-driven events in zkWasm.</p>"},{"location":"development-guide/Implementing%20Time-Driven%20Events.html#implementation-components","title":"Implementation Components","text":"<p>To implement time-driven events in zkWasm, we'll work with several components:</p> <ul> <li>zkWasm Mini Rollup (SDK &amp; Server): <ul> <li>zkWasm-ts-server: Generates timetick transactions</li> <li>Event conventions: Defines data structures and event handling interfaces</li> </ul> </li> <li>zkWasm Application:<ul> <li>state.rs: Manages application state</li> <li>event.rs: Implements event handling methods</li> </ul> </li> </ul> <p>Note</p> <p>This guide uses the automata game as an example. Your application may use different file names than <code>state.rs</code> and <code>event.rs</code>.</p>"},{"location":"development-guide/Implementing%20Time-Driven%20Events.html#timetick-transactions","title":"Timetick Transactions","text":"<p>First, enable timetick transactions in your application's <code>config.ts</code> (default is true):</p> <pre><code>impl Config {\n    ...\n    pub fn autotick() -&gt; bool {\n        true\n    }\n}\n</code></pre> <p>Once enabled, the server (<code>service.ts</code> in <code>zkWasm-ts-server/src</code>) will generate timetick transactions at regular intervals:</p> <pre><code>// Generate timetick transactions if autotick is enabled\nif (application.autotick()) {\n    setInterval(async () =&gt; {\n        try {\n            await myQueue.add('autoJob', {command:0});\n        } catch (error) {\n            console.error('Error adding automatic job to the queue:', error);\n            process.exit(1);\n        }\n    }, 5000); // Default interval: 5 seconds (adjustable)\n}\n</code></pre> <p>You can customize the interval by modifying the <code>setInterval</code> timing parameter.</p>"},{"location":"development-guide/Implementing%20Time-Driven%20Events.html#event-convention","title":"Event Convention","text":"<p>The event convention defines the core data structures and interfaces for handling time-driven events. Let's examine the key components:</p>"},{"location":"development-guide/Implementing%20Time-Driven%20Events.html#eventqueue-structure","title":"EventQueue Structure","text":"<p>The EventQueue implements a differential time queue (DTQ) for efficient event scheduling and processing:</p> <pre><code>pub struct EventQueue&lt;T: EventHandler + Sized&gt; {\n    pub counter: u64,  // Total number of timeticks processed\n    pub list: std::collections::LinkedList&lt;T&gt;,  // Ordered queue of pending events\n}\n</code></pre>"},{"location":"development-guide/Implementing%20Time-Driven%20Events.html#eventhandler-interface","title":"EventHandler Interface","text":"<p>Events must implement the EventHandler trait, which defines the core event handling behavior:</p> <pre><code>pub trait EventHandler: Clone + StorageData {\n    fn get_delta(&amp;self) -&gt; usize;  // Time until event triggers\n    fn progress(&amp;mut self, d: usize);  // Update event's remaining time\n    fn handle(&amp;mut self, counter: u64) -&gt; Option&lt;Self&gt;;  // Process event and optionally chain a new one\n    fn u64size() -&gt; usize;  // Number of u64 fields in the event\n}\n</code></pre>"},{"location":"development-guide/Implementing%20Time-Driven%20Events.html#eventqueue-implementation","title":"EventQueue Implementation","text":"<p>The EventQueue provides several methods for managing events:</p> <pre><code>impl&lt;T: EventHandler&gt; EventQueue&lt;T&gt; {\n    // Debug helper - prints queue state\n    fn dump(&amp;self, counter: u64)\n\n    // Add new event to queue\n    pub fn insert(&amp;mut self, node: T)\n\n    // Process due events and advance time\n    pub fn tick(&amp;mut self)\n\n    // Storage management\n    fn get_old_entries(&amp;self, counter: u64) -&gt; Vec&lt;u64&gt;\n    fn set_entries(&amp;self, entries: &amp;Vec&lt;u64&gt;, counter: u64)\n    pub fn store(&amp;mut self)\n}\n</code></pre> <p>Key operations include:</p> <ul> <li> <p><code>dump</code>: Prints the event queue and the delta of each event for debugging purposes. Shows the current counter and the delta time for each event in the queue.</p> </li> <li> <p><code>insert</code>: Adds a new event into the event queue based on its delta time. The event queue is a differential time queue (DTQ), meaning events are sorted by their relative time differences. The method adjusts delta times of subsequent events to maintain proper time relationships.</p> </li> <li> <p><code>tick</code>: The core processing function that:</p> <ol> <li>Retrieves and processes historical events from storage:    <pre><code> let mut entries_data = self.get_old_entries(counter);\n let entries_nb = entries_data.len() / E::u64size();\n let mut dataiter = entries_data.iter_mut();\n let mut entries = Vec::with_capacity(entries_nb);\n for _ in 0..entries_nb {\n     entries.push(E::from_data(&amp;mut dataiter));\n }\n</code></pre></li> <li>Handles all events with zero delta time in the queue through the <code>handle()</code> method. Each event's <code>handle()</code> method may generate new events that get inserted back into the queue: <pre><code>for mut e in entries {\n    let m = e.handle(counter);\n\n    if let Some(event) = m {\n        self.insert(event);\n    }\n}\n\nwhile let Some(head) = self.list.front_mut() {\n    if head.get_delta() == 0 {\n        let m = head.handle(counter);\n        self.list.pop_front();\n        if let Some(event) = m {\n            self.insert(event); // new event generated and inserted back into the queue\n        }\n    }else{\n        ...\n    }\n    ...\n}\n</code></pre></li> <li>Progresses remaining events by reducing their delta by 1: <pre><code>if head.get_delta() == 0 {\n    ...\n} else {\n    head.progress(1);\n    break; // break the while loop\n}\n</code></pre></li> <li>Increments the counter by 1.</li> </ol> </li> <li> <p><code>get_old_entries</code>: Retrieves historical event data from storage for a given counter value. Used to load previously stored events that need processing.</p> </li> <li> <p><code>set_entries</code>: Stores event data in the merkle key-value storage for a specific counter value. This helps manage memory by persisting events that will be processed at the same time.</p> </li> <li> <p><code>store</code>: Persists the entire event queue to the merkle storage. This ensures event data survives between application restarts as well as the rollup process.</p> </li> </ul> <p>Keep in mind these data structures, interface and methods, now we will leverage these components to implement time-driven events in zkWasm.</p>"},{"location":"development-guide/Implementing%20Time-Driven%20Events.html#state-management","title":"State Management","text":"<p>In automata game, we have a <code>state.rs</code> file which defines and manages the state of the application, including the events.</p> <p>First, in order to use the EventQueue Struct, we can import it as follows: <pre><code>use zkwasm_rest_convention::EventQueue;\n</code></pre></p> <p>Note</p> <p>In your rust project dependency, you need to add the <code>zkwasm-rest-convention</code> crate to your <code>Cargo.toml</code> file: <pre><code>zkwasm-rest-convention = { git = \"https://github.com/DelphinusLab/zkwasm-mini-rollup\" }\n</code></pre></p> <p>Then, we simply add the EventQueue Struct to the state of the application:</p> <pre><code>pub struct State {\n    // Other state fields...\n    queue: EventQueue&lt;Event&gt;,\n}\n</code></pre> <p>Note that in the <code>initialize()</code> function of the State implementation, we need to retrieve the queue field. This happens every time the application is initialized, either when the server restarts or after the rollup process is finalized:</p> <pre><code>pub fn initialize() {\n    let mut state = STATE.0.borrow_mut();\n    let kvpair = unsafe { &amp;mut MERKLE_MAP };\n    let mut data = kvpair.get(&amp;[0, 0, 0, 0]);\n\n    if !data.is_empty() {\n        let mut data = data.iter_mut();\n        state.supplier = *data.next().unwrap();\n        state.queue = EventQueue::from_data(&amp;mut data);\n    }\n}\n</code></pre> <p>And in the <code>process</code> function of the Transaction struct, we have:</p> <pre><code>impl Transaction {\n    pub fn process(&amp;self) -&gt; i32 {\n        match self.command {\n            // Handle timetick transactions\n            0 =&gt; {\n                // Ensure only the admin/sequencer can trigger ticks\n                unsafe { require(*pkey == *ADMIN_PUBKEY) };\n                STATE.0.borrow_mut().queue.tick();\n                0\n            }\n            // Other transaction types...\n        }\n    }\n}\n</code></pre> <p>This is the place where we call the <code>tick()</code> method of the event queue to process the events. You may notice that we have a <code>require(*pkey == *ADMIN_PUBKEY)</code> statement, which is used to check if the transaction is sent by the admin account. This is to ensure that only the admin account which controlled by the server or sequencer can trigger the event processing, which is a good practice to prevent any malicious behavior that attempt to process the events without proper timetick transactions.</p>"},{"location":"development-guide/Implementing%20Time-Driven%20Events.html#event-handling","title":"Event Handling","text":"<p>Now we have the event queue in the state, we can implement the event handling methods in the <code>event.rs</code> file, this may be the most relevant and important part of the time-driven events.</p> <p>In event.rs, we need to import several components:</p> <pre><code>use crate::player::AutomataPlayer;\nuse core::slice::IterMut;\nuse zkwasm_rest_abi::StorageData;\nuse zkwasm_rest_convention::EventHandler;\n</code></pre> <ul> <li> <p>We need <code>AutomataPlayer</code> because when handling the event, we need to update the state of the player.</p> </li> <li> <p>We need <code>core::slice::IterMut</code> to iterate over the event fields which we will define later, to get data of each field from database. This is because we serialize the event fields into a u64 array, and we need to deserialize them back to the original data structure through iterating the u64 array.</p> </li> <li> <p>We need <code>zkwasm_rest_abi::StorageData</code> to implement the necessary methods for serializing and deserializing a event into a u64 array.</p> </li> <li> <p>We need <code>zkwasm_rest_convention::EventHandler</code> to implement the methods for event handling interface.</p> </li> </ul> <p>Let's define an simple event as an example:</p> <pre><code>pub struct Event {\n    pub owner: [u64; 2],\n    pub object_index: usize,\n    pub delta: usize,\n}\n</code></pre> <p>Where the <code>owner</code> field is a 2-element array of u64 indicating the ID of a specific player, and the <code>object_index</code> indicates the index of the object in the game. The delta field indicates the time interval of the event, which is the time period after which the event will be triggered.</p> <p>And here we implement the StorageData Trait for the Event:</p> <pre><code>impl StorageData for Event {\n    fn to_data(&amp;self, buf: &amp;mut Vec&lt;u64&gt;) {\n        buf.push(self.owner[0]);\n        buf.push(self.owner[1]);\n        buf.push(((self.object_index as u64) &lt;&lt; 32) | self.delta as u64);\n    }\n    fn from_data(u64data: &amp;mut IterMut&lt;u64&gt;) -&gt; Event {\n        let owner = [*u64data.next().unwrap(), *u64data.next().unwrap()];\n        let f = *u64data.next().unwrap();\n        Event {\n            owner,\n            object_index: (f &gt;&gt; 32) as usize,\n            delta: (f &amp; 0xffffffff) as usize,\n        }\n    }\n}\n</code></pre> <p>In the <code>to_data()</code> method, we serialize the event fields into a u64 array, and in the <code>from_data()</code> method, we deserialize the u64 array back to the original data structure. </p> <p>Now we can Implement the EventHandler Trait for the Event:</p> <pre><code>impl EventHandler for Event {\n    fn u64size() -&gt; usize {\n        3\n    }\n    fn get_delta(&amp;self) -&gt; usize {\n        self.delta\n    }\n    fn progress(&amp;mut self, d: usize) {\n        self.delta -= d;\n    }\n    fn handle(&amp;mut self, counter: u64) -&gt; Option&lt;Self&gt; {\n        ...\n    }\n}\n</code></pre> <p>The <code>u64size()</code> method returns the number of u64 elements in the event, in our implementation, we have 3 u64 elements in the event, so we return 3.</p> <p>The <code>get_delta()</code> method returns the delta time of the event.</p> <p>The <code>progress()</code> method is used to progress the event by the given delta time, which is used to reduce the delta time of the event. In our implementation of <code>tick()</code> method, we use <code>progress(1)</code> to progress the event by 1.</p> <p>The <code>handle()</code> method is the most important one, which is used to handle the event, and maybe return the next event:</p> <pre><code>fn handle(&amp;mut self, counter: u64) -&gt; Option&lt;Self&gt; {\n    let owner_id = self.owner;\n    let object_index = self.object_index;\n    let mut player = AutomataPlayer::get_from_pid(&amp;owner_id).unwrap();\n    let m = if player.data.energy == 0 {\n        player.data.objects.get_mut(object_index).unwrap().halt();\n        None\n    } else {\n        player.data.apply_object_card(object_index, counter)\n    };\n    let event = if let Some(delta) = m {\n        if player.data.objects[object_index].get_modifier_index() == 0 {\n            player.data.energy -= 1;\n        }\n        Some(Event {\n            owner: owner_id,\n            object_index,\n            delta,\n        })\n    } else {\n        None\n    };\n    player.store();\n    event\n}\n</code></pre> <p>Notice that in handle() method, we:</p> <ol> <li>Get the player data through <code>owner_id</code></li> <li>Get the object data through <code>object_index</code> from the player data</li> <li>Check if the player has enough energy:<ul> <li>If energy is 0, halt the object and return None</li> <li>If energy &gt; 0, call apply_object_card() to process the object's card effects</li> </ul> </li> <li>Process the result from apply_object_card():<ul> <li>If it returns Some(delta), create a new Event with:<ul> <li>Same owner_id</li> <li>Same object_index</li> <li>The returned delta as the new time interval</li> <li>Additionally, if the object's modifier_index is 0, decrease player's energy by 1</li> </ul> </li> <li>If it returns None, no new event is created</li> </ul> </li> <li>Store the updated player state back to storage</li> <li>Return the optional new Event</li> </ol> <p>Summary</p> <p>In summary, in this method, we can:</p> <ol> <li>Retrieve the player data or object data we need to modify</li> <li>Modify the player data or object data based on the timetick. For example, every timetick (5 seconds), we can decrease the energy of the player by 1. In the above case, we have a condition to check if the player has enough energy, if not, we halt the object. if the player has enough energy, we can apply the object's card effects.</li> <li>Check the data after modification based on some conditions, if the conditions are met, we can create a new event.</li> <li>Return the new event if it is created, otherwise return None. Don't forget to store the updated player state back to storage.</li> </ol>"},{"location":"development-guide/Web3%20Development%20Frameworks.html","title":"Web3 Development Frameworks","text":""},{"location":"development-guide/Web3%20Development%20Frameworks.html#frontend-development","title":"Frontend Development","text":"<p>Frontend SDKs play a crucial role in Web3 development by providing seamless integration of essential features. These SDKs simplify complex blockchain interactions, offering ready-to-use components for wallet connections, social login integration, smart contract interactions, and transaction signing. For developers new to Web3, these tools significantly reduce the learning curve and development time.</p> <p>Popular frontend frameworks like Web3.js and Ethers.js serve as the foundation for many Web3 applications. They handle the low-level communication with blockchain networks and provide intuitive APIs for common operations. Additionally, frameworks like wagmi and RainbowKit offer React-specific solutions with pre-built components and hooks for rapid development.</p>"},{"location":"development-guide/Web3%20Development%20Frameworks.html#backend-development","title":"Backend Development","text":"<p>Backend SDKs are equally important in the Web3 ecosystem, providing developers with tools for server-side blockchain interactions, data indexing, and API integration. These SDKs enable features such as transaction monitoring, webhook implementations, and efficient data querying from blockchain networks. They also handle important aspects like key management, transaction signing, and gas optimization on the server side. For example, Thirdweb provides a comprehensive backend SDK and engine suite that supports multiple platforms, including web, mobile, and game development. </p> <p>Note</p> <p>Since zkWasm currently only provides good support for Rust, we recommend developing microservices in other languages if your project requires them. For example, you can use JavaScript/TypeScript to build backend services that listen to events and interact with your zkWasm Rollup Application through RPC calls.</p>"},{"location":"development-guide/Web3%20Development%20Frameworks.html#game-development-frameworks","title":"Game Development Frameworks","text":"<p>The gaming sector has seen significant growth in Web3, with several robust frameworks available for different game engines:</p>"},{"location":"development-guide/Web3%20Development%20Frameworks.html#unity-solutions","title":"Unity Solutions","text":"<p>Moralis's Unity Web3 Game Kit offers a comprehensive solution for blockchain integration in Unity games. It provides features like wallet connection, NFT handling, and token transactions with minimal setup required. The kit is particularly valuable for developers looking to add Web3 functionality to existing Unity projects.</p> <p>ChainSafe's Web3.unity SDK provides another powerful option, focusing on performance and ease of use. It offers extensive documentation and examples, making it ideal for developers new to blockchain gaming.</p>"},{"location":"development-guide/Web3%20Development%20Frameworks.html#unreal-engine-solutions","title":"Unreal Engine Solutions","text":"<p>Mirage Gaming SDK and Venly Gaming SDK both offer robust solutions for Unity and Unreal Engine integration. These frameworks provide essential Web3 functionality while maintaining the high performance standards expected in game development.</p>"},{"location":"development-guide/Web3%20Development%20Frameworks.html#cross-platform-development","title":"Cross-Platform Development","text":"<p>Thirdweb stands out by offering a unified solution across multiple platforms. Their SDK suite supports:</p> <ul> <li>TypeScript for web development</li> <li>React and React Native for mobile applications</li> <li>.NET for backend services (also Game Development for Frameworks like Godot Engine)</li> <li>Unity and Unreal Engine for game development</li> </ul> <p>This cross-platform support makes Thirdweb particularly valuable for teams working on multi-platform projects.</p>"},{"location":"development-guide/Web3%20Development%20Frameworks.html#other-development-tools-and-resources","title":"Other Development Tools and Resources","text":"<p>Alchemy provides a comprehensive collection of developer tools that can significantly enhance the Web3 development process. </p> <p>For game developers, Alchemy has a gaming tools collection that can help you build your game.</p> <p>For beginners, it's recommended to start with one of the more established frameworks and gradually explore additional tools as needed. The key is to choose tools that offer good documentation, active community support, and regular updates to ensure a smooth development experience.</p> <p>Disclaimer</p> <p>Please note that while we strive to provide accurate and up-to-date information about Web3 development frameworks and tools, the blockchain technology landscape evolves rapidly. We encourage all developers to:</p> <ul> <li>Do Your Own Research (DYOR) before implementing any framework or tool</li> <li>Thoroughly review the documentation and security considerations of each tool</li> <li>Test extensively in development environments before deploying to production</li> <li>Stay updated with the latest versions and security patches</li> <li>Verify the activity and support level of the community around each tool</li> </ul> <p>The frameworks and tools mentioned in this document are provided for informational purposes only. We do not endorse any specific solution and are not responsible for any issues or losses that may arise from their use. Always exercise due diligence and professional judgment when choosing development tools for your projects.</p>"},{"location":"development-guide/zkWasm%20Rust%20SDK.html","title":"zkWasm Rust SDK and REST ABI","text":""},{"location":"development-guide/zkWasm%20Rust%20SDK.html#overview-of-zkwasm-rust-sdk-and-rest-service-abi","title":"Overview of zkWasm Rust SDK and REST Service ABI","text":"<p>The zkWasm Rust SDK provides essential building blocks for developing zero-knowledge WebAssembly applications. Such as Host(Builtin) Functions like Input/Output, Merkle Tree, Poseidon Signature, etc, and also some useful traits for state management and trace such as key-value pair storage, debug print, etc.</p> <p>You can import the SDK in your rollup application by adding the following line to your <code>Cargo.toml</code> file: <pre><code>[dependencies]\n...\nzkwasm-rust-sdk = { git = \"https://github.com/DelphinusLab/zkWasm-rust.git\", default-features = true }\n</code></pre></p>"},{"location":"development-guide/zkWasm%20Rust%20SDK.html#1-usage-of-zkwasm-rust-sdk","title":"1. Usage of zkWasm Rust SDK","text":"<p>You can view the available modules in the lib.rs file.</p> <p>For example, if you want to use the Merkle Tree, you can import it as follows: <pre><code>use zkwasm_rust_sdk::Merkle;\n</code></pre> And then you can use the Merkle Tree in your code: <pre><code>let merkle = zkwasm_rust_sdk::Merkle::new();\n</code></pre></p>"},{"location":"development-guide/zkWasm%20Rust%20SDK.html#debugging","title":"Debugging","text":"<p>if you want to debug the state, you can insert the following code into your rust code: <pre><code>zkwasm_rust_sdk::dbg!(\"debug message\");\n</code></pre></p>"},{"location":"development-guide/zkWasm%20Rust%20SDK.html#condition-check","title":"Condition Check","text":"<p>if you want to check the condition, you can insert the following code into your rust code: <pre><code>unsafe { zkwasm_rust_sdk::require(condition); }\n</code></pre></p> <p>Let's explore the key components through the following example, the zkwasm REST ABI, which defines the interface between the zkWasm rollup and zkWasm Application Server using zkWasm Rust SDK. You can view the full code in zkwasm-mini-rollup/abi/src/lib.rs file.</p>"},{"location":"development-guide/zkWasm%20Rust%20SDK.html#2-import-key-modules","title":"2. Import Key Modules","text":"<p>In the example code, we import the following modules from the zkWasm Rust SDK:</p> <p><pre><code>...\nuse zkwasm_rust_sdk::jubjub::BabyJubjubPoint;\nuse zkwasm_rust_sdk::jubjub::JubjubSignature;\nuse zkwasm_rust_sdk::kvpair::KeyValueMap;\nuse zkwasm_rust_sdk::Merkle;\n...\n</code></pre> Let's explore how these modules are used in the following sections.</p>"},{"location":"development-guide/zkWasm%20Rust%20SDK.html#3-storage-and-state-management","title":"3. Storage and State Management","text":"<p>The storage and state management system provides the foundation for maintaining application data. It consists of two main components: a Merkle tree for state verification and retrieval, and a key-value store for efficient data access.</p>"},{"location":"development-guide/zkWasm%20Rust%20SDK.html#merkle-tree-state","title":"Merkle Tree State","text":"<pre><code>pub static mut MERKLE_MAP: KeyValueMap&lt;Merkle&gt; = KeyValueMap {\n    merkle: Merkle { root: [...] }\n};\n</code></pre> <ul> <li>Manages application state using a Merkle tree structure</li> <li>Provides cryptographic verification of state changes</li> <li>Uses a key-value store for efficient data access</li> </ul>"},{"location":"development-guide/zkWasm%20Rust%20SDK.html#storagedata-trait","title":"StorageData Trait","text":"<pre><code>pub trait StorageData {\n    fn from_data(u64data: &amp;mut IterMut&lt;u64&gt;) -&gt; Self;\n    fn to_data(&amp;self, u64data: &amp;mut Vec&lt;u64&gt;);\n}\n</code></pre> <ul> <li>Defines interface for serializing/deserializing state data</li> <li>Enables custom data structures to be stored in Merkle tree</li> <li>Provides consistent data handling across the application</li> </ul>"},{"location":"development-guide/zkWasm%20Rust%20SDK.html#4-player-management-system","title":"4. Player Management System","text":"<p>When developing a zkWasm application, you need to manage players (or users) and their associated data. The player management system is essential for tracking user accounts and their state.</p>"},{"location":"development-guide/zkWasm%20Rust%20SDK.html#player-structure","title":"Player Structure","text":"<p><pre><code>#[derive(Debug, Serialize)]\npub struct Player&lt;T: StorageData + Default&gt; {\n    pub player_id: [u64; 2],\n    pub nonce: u64,\n    pub data: T,\n}\n</code></pre> Key features:</p> <ul> <li>Generic implementation allowing custom player data</li> <li>Built-in nonce management for transaction ordering</li> <li>Serializable for state persistence</li> <li><code>StorageData</code> trait bounds ensuring proper state handling</li> </ul>"},{"location":"development-guide/zkWasm%20Rust%20SDK.html#player-operations","title":"Player Operations","text":"<pre><code>impl&lt;T: StorageData + Default&gt; Player&lt;T&gt; {\n    pub fn store(&amp;self) { ... }\n    pub fn new_from_pid(pid: [u64; 2]) -&gt; Self { ... }\n    pub fn get_from_pid(pid: &amp;[u64; 2]) -&gt; Option&lt;Self&gt; { ... }\n    pub fn get_and_check_nonce(pid: &amp;[u64; 2], nonce: u64) -&gt; Self { ... }\n}\n</code></pre> <ul> <li>State persistence with Merkle tree integration</li> <li>Player creation and retrieval functionality</li> <li>Nonce validation and management</li> </ul>"},{"location":"development-guide/zkWasm%20Rust%20SDK.html#5-zkwasm-rest-abi","title":"5. zkWasm REST ABI","text":"<p>zkWasm REST service ABI is the convention between the sequencer (implemented in typescript) and the provable application. It contains three parts:</p> <ul> <li>Transaction</li> <li>State</li> <li>Config</li> </ul> <p>In the Application side, this macro from zkwasm_rest_abi generates essential bindings for zkWasm applications: <pre><code>zkwasm_rest_abi::create_zkwasm_apis!(Transaction, State, Config);\n</code></pre></p>"},{"location":"development-guide/zkWasm%20Rust%20SDK.html#system-architecture-and-flow","title":"System Architecture and Flow","text":"<p>Now we delve into the REST service ABI to see how it constructs the framework for the zkWasm rollup Application. Above figure shows the system execution flow of zkWasm rollup application, and below we will explain each phase in detail.</p>"},{"location":"development-guide/zkWasm%20Rust%20SDK.html#1-initialization-phase","title":"1. Initialization Phase","text":"<p>The initialization phase in zkWasm rollup serves two critical purposes:</p> <ul> <li>Loading previous chunk's finalized state</li> <li>Setting up new execution environment for transactions</li> </ul> <p><pre><code>pub fn initialize(root: Vec&lt;u64&gt;) {\n    // Load initial Merkle root state\n    let merkle = zkwasm_rust_sdk::Merkle::load([root[0], root[1], root[2], root[3]]);\n    MERKLE_MAP.merkle = merkle;\n    $S::initialize();\n}\n</code></pre> The code above:</p> <ul> <li>Loads initial state from provided Merkle root</li> <li>Sets up state for new transaction input bundle</li> <li>Called at the start of each transaction chunk processing</li> </ul>"},{"location":"development-guide/zkWasm%20Rust%20SDK.html#2-transaction-processing-phase","title":"2. Transaction Processing Phase","text":"<p>The transaction processing phase in zkWasm rollup fulfills three essential roles:</p> <ul> <li>Sequential execution of user transactions</li> <li>Maintaining state consistency during updates</li> <li>Accumulating settlement information for later batching</li> </ul> <p><pre><code>// In zkmain()\nfor _ in 0..tx_length {\n    let mut params = Vec::with_capacity(24);\n    for _ in 0..24 {\n        params.push(unsafe {wasm_input(0)});\n    }\n    verify_tx_signature(params.clone());\n    handle_tx(params);\n}\n</code></pre> The code above:</p> <ul> <li>Processes transactions until preemption point</li> <li>Each transaction verified and executed sequentially</li> <li>State updates tracked in Merkle tree</li> </ul>"},{"location":"development-guide/zkWasm%20Rust%20SDK.html#3-preemption-check","title":"3. Preemption Check","text":"<p>The preemption mechanism in zkWasm rollup serves two vital functions:</p> <ul> <li>Controlling chunk size for computational efficiency</li> <li>Ensuring deterministic chunk boundaries</li> </ul> <p><pre><code>pub fn preempt() -&gt; bool {\n    $S::preempt()  // Check if state reached preemption point\n}\n</code></pre> The code above:</p> <ul> <li>Determines when to stop processing transactions</li> <li>Usually based on state conditions or limits, such as a counter threshold</li> <li>Critical for chunk management</li> </ul> <p><pre><code>pub fn preempt() -&gt; bool {\n    let state = unsafe {&amp;STATE};\n    return state.counter % 20 == 0;  \n}\n</code></pre> For example, in code above, if the counter is divisible by 20 (every 20 transactions), the preemption point is reached and the transaction processing will stop.</p>"},{"location":"development-guide/zkWasm%20Rust%20SDK.html#4-state-finalization","title":"4. State Finalization","text":"<p>The finalization phase in zkWasm rollup serves two critical purposes:</p> <ul> <li>Processing all pending settlements</li> <li>Generating verifiable outputs for the chain</li> </ul> <p>The finalize() function in zkWasm API triggers the settlement process: <pre><code>pub fn finalize() -&gt; Vec&lt;u8&gt; {\n    unsafe {\n        $S::flush_settlement()\n    }\n}\n</code></pre></p> <p>Here's an example from <code>abi/src/lib.rs</code> that demonstrates how the bundled logic is implemented within the <code>zkmain</code> function. The finalization process produces two key outputs:</p> <ul> <li>New State Root (root)<ul> <li>4 u64 values representing the Merkle root</li> <li>Captures final state after all transactions</li> <li>Used to initialize next chunk's state</li> </ul> </li> <li>Settlement Hash (txdata)<ul> <li>4 u64 values containing SHA256 hash</li> <li>Computed from all withdrawals/settlements</li> <li>Used for on-chain verification of batched operations    </li> </ul> </li> </ul> <p>Here's the template structure:</p> <p><pre><code>// Step 1: Get settlement data the same way as in the finalize() function\nlet bytes = $S::flush_settlement();\n\n// Step 2: Generate transaction info hash\nlet txdata = conclude_tx_info(bytes.as_slice());\n// txdata is [u64; 4] - contains SHA256 hash of settlement data\n\n// Step 3: Get final Merkle root\nlet root = merkle_ref.merkle.root;  // [u64; 4]\n\n// Step 4: Output all data\nunsafe {\n    // Output Merkle root (4 u64 values)\n    wasm_output(root[0]);\n    wasm_output(root[1]);\n    wasm_output(root[2]);\n    wasm_output(root[3]);\n\n    // Output transaction data hash (4 u64 values)\n    wasm_output(txdata[0]);\n    wasm_output(txdata[1]);\n    wasm_output(txdata[2]);\n    wasm_output(txdata[3]);\n}\n</code></pre> The code above:</p> <ul> <li>Generates new Merkle root for next chunk</li> <li>Outputs settlement information</li> <li>Ensures state consistency across chunks</li> </ul>"},{"location":"development-guide/zkWasm%20Rust%20SDK.html#rollup-development-requirements","title":"Rollup Development Requirements","text":"<p>In application side, the following requirements (API) shall be met to ensure the rollup process works properly:</p>"},{"location":"development-guide/zkWasm%20Rust%20SDK.html#1-state-implementation","title":"1. State Implementation","text":"<pre><code>impl State {\n    fn preempt() -&gt; bool { ... }  // Define chunk boundary conditions\n    fn initialize() { ... }        // Setup initial state\n    fn flush_settlement() -&gt; Vec&lt;u8&gt; { ... } // Get the settlement info\n}\n</code></pre> <p>And some other functions can be implemented in the <code>State</code> trait. <pre><code>pub trait State {\n    fn preempt() -&gt; bool; // Define chunk boundary conditions and check if the state reaches the preemption point\n    fn initialize(); // Initialize the state at beginning\n    fn flush_settlement() -&gt; Vec&lt;u8&gt;; // Get the settlement info\n    // Some other functions\n    fn get_state(pid: Vec&lt;u64&gt;) -&gt; String { ... } // Get state for specific player ID\n    fn snapshot() -&gt; String { ... } // Get current global state\n    fn tick(&amp;mut self) { ... } // Update state if auto-tick is enabled\n    fn store(&amp;self) { ... } // Store state to Merkle tree\n    fn new() -&gt; Self { ... } // Create new state instance\n    fn rand_seed() -&gt; u64 { ... } // Get the current hash of the random seed\n}\n</code></pre></p>"},{"location":"development-guide/zkWasm%20Rust%20SDK.html#2-transaction-processing","title":"2. Transaction Processing","text":"<pre><code>impl Transaction {\n    fn decode(command: [u64; 4]) -&gt; Self { ... } // Decode Command      \n    fn process(&amp;self, user_address: &amp;[u64; 4], sig_r: &amp;[u64; 4]) -&gt; u32 { ... } // Process Transaction\n    fn install_player(&amp;self, pkey: &amp;[u64; 4]) -&gt; u32 { ... } // Create player / user Account\n    fn decode_error(e) // Decode error code to description\n}\n</code></pre>"},{"location":"development-guide/zkWasm%20Rust%20SDK.html#3-configuration-management","title":"3. Configuration Management","text":"<pre><code>impl Config {\n    fn autotick() -&gt; bool { ... } // Auto-tick configuration\n    fn to_json_string() -&gt; String { ... } // Convert to JSON string\n}\n</code></pre>"},{"location":"development-guide/zkWasm%20Rust%20SDK.html#example-rollup-flow","title":"Example Rollup Flow","text":"<pre><code>// 1. Initialize state with previous Merkle root\ninitialize(previous_root);\n\n// 2. Process transaction batch\nwhile !preempt() {\n    verify_tx_signature(params);\n    handle_tx(params);\n}\n\n// 3. Generate new Merkle root and settlement data\nfinalize();\n// ...\n</code></pre> <p>At the beginning of each chunk, the state is initialized. After the initialization, an array of transactions are handled until the state reaches its preemption point. After the preemption point is reached, the state is stored and the bundle outputs the new merkle root which will be used for the following bundle. Based on this template, we can implement a few APIs for the whole application to work as a rollup.</p>"},{"location":"development-guide/zkWasm%20Rust%20SDK.html#function-overview","title":"Function Overview","text":""},{"location":"development-guide/zkWasm%20Rust%20SDK.html#1-transaction-handling","title":"1. Transaction Handling","text":"<pre><code>pub fn handle_tx(params: Vec&lt;u64&gt;) -&gt; u32 // Process transaction\n</code></pre> <ul> <li>Params format (24 u64 values)<ul> <li>[0-3]: Command data</li> <li>[4-7]: User address</li> <li>[20-23]: Signature data</li> </ul> </li> <li>Returns error code (0 for success)</li> </ul>"},{"location":"development-guide/zkWasm%20Rust%20SDK.html#2-state-management","title":"2. State Management","text":"<pre><code>pub fn get_state(pid: Vec&lt;u64&gt;) -&gt; String // Get state for specific player ID\npub fn snapshot() -&gt; String // Get current global state\n</code></pre> <ul> <li><code>get_state</code>: Retrieves state for specific player ID</li> <li><code>snapshot</code>: Gets current global state</li> <li>Both return JSON-formatted strings</li> </ul>"},{"location":"development-guide/zkWasm%20Rust%20SDK.html#3-configuration-and-control","title":"3. Configuration and Control","text":"<pre><code>pub fn get_config() -&gt; String // Get configuration\npub fn preempt() -&gt; bool  // Preemption check (whether to generate proof at this stage)\npub fn autotick() -&gt; bool // Auto-tick configuration\npub fn randSeed() -&gt; u64  // Get the current hash of the random seed\n</code></pre> <ul> <li>Configuration retrieval and system controls</li> <li>All WebAssembly-exposed functions</li> </ul>"},{"location":"getting-started/Development%20Workflow.html","title":"Development Workflow","text":""},{"location":"getting-started/Development%20Workflow.html#guideline","title":"Guideline","text":"<p>This workflow will guide you through the process of developing a zkWasm application. You can find reference chapters corresponding to each step in the workflow. The workflow follows a five-category cycle:</p> <ol> <li>Learn: Learn the basics of zkWasm and the zkWasm Mini-Rollup service</li> <li>Design: Design your application as a state machine</li> <li>Develop: Develop your application in Rust</li> <li>Test: Test your application with zkwasm-ts-server</li> <li>Deploy: Deploy your application to the zkWasm Hub and blockchain</li> </ol>"},{"location":"getting-started/Development%20Workflow.html#development-workflow_1","title":"Development Workflow","text":""},{"location":"getting-started/Development%20Workflow.html#learn","title":"Learn","text":"<ol> <li>Understand Web Application Development</li> <li>Understand Blockchain Engineering and Zero-Knowledge Proof</li> <li>Understand zkWasm Basics and Architecture</li> </ol>"},{"location":"getting-started/Development%20Workflow.html#design","title":"Design","text":"<ol> <li>Design your application as a State Machine</li> <li>Choose your Development Language and Frameworks</li> </ol>"},{"location":"getting-started/Development%20Workflow.html#develop","title":"Develop","text":"<ol> <li>Set up Environment</li> <li>Get started with Quick Tutorial</li> </ol>"},{"location":"getting-started/Development%20Workflow.html#backend","title":"Backend","text":"<ol> <li>Install zkWasm-Mini-Rollup</li> <li>Develop your zkWasm application in Rust using Rust SDK</li> <li>[Optional] Implement Time-Driven Events and Random Numbers features</li> </ol>"},{"location":"getting-started/Development%20Workflow.html#frontend","title":"Frontend","text":"<ol> <li>Develop Frontend and User Interface using Web3 Development Frameworks</li> <li>Implement RPC calls in the frontend to interact with the zkWasm application</li> </ol>"},{"location":"getting-started/Development%20Workflow.html#smart-contract","title":"Smart Contract","text":"<ol> <li>[Optional] Develop custom smart contracts like Token or Custom Transaction Contract</li> <li>[Optional] Develop custom Settlement Monitor and Deposit Monitor</li> </ol>"},{"location":"getting-started/Development%20Workflow.html#test","title":"Test","text":"<ol> <li>Test the zkWasm application internally with State Validation</li> <li>Test the zkWasm application from the frontend with zkwasm-ts-server</li> <li>[Optional] Test the state retrival by merkle tree root</li> <li>Test your smart contracts with deposit and settlement monitors</li> </ol>"},{"location":"getting-started/Development%20Workflow.html#deploy","title":"Deploy","text":"<ol> <li>Deploy the zkWasm Mini Rollup application to the zkWasm Hub</li> <li>Deploy the Frontend code</li> <li>Deploy the zkWasm Protocol smart contract to the target blockchain</li> <li>Deploy the Withdraw Transaction Contract to the target blockchain</li> <li>Deploy other smart contracts like token or custom Transaction Contract</li> <li>Deploy the Settlement Monitor</li> <li>Deploy the Deposit Monitor</li> </ol>"},{"location":"getting-started/Quick%20Tutorial.html","title":"Quick Tutorial","text":""},{"location":"getting-started/Quick%20Tutorial.html#guideline","title":"Guideline","text":"<p>This tutorial will guide you through the process of creating a simple zkWasm application in minutes. Please make sure you have already setup the environment by following the Setup Environment guide.</p> <p>Quick Start with zkWasm DApp CLI</p> <p>You can also try our brand new zkWasm DApp CLI to create a new project conveniently. The CLI provides:</p> <ul> <li>\ud83c\udfaf Quick project generation from templates</li> <li>\ud83d\udd0d Smart deployment checks</li> <li>\u2699\ufe0f Automatic environment configuration</li> <li>\ud83d\udce6 Multiple project templates</li> <li>\ud83d\udee0\ufe0f Built-in development tools</li> </ul> <pre><code># Install globally\nnpm install -g zkwasm-dapp-cli\n\n# Create a new project\nzkwasm-dapp create my-zkwasm-app\n</code></pre>"},{"location":"getting-started/Quick%20Tutorial.html#step-1-install-the-zkwasm-mini-rollup-service","title":"Step 1: Install the zkWasm Mini-Rollup service","text":"<p>The zkWasm Mini-Rollup service is a RESTful service that provides the zkWasm runtime environment. It provides the following functionalities:</p> <ul> <li>Serve the zkWasm runtime environment</li> <li>Provide the zkWasm REST ABI</li> <li>Maintain the zkWasm state through merkle tree enabled database and Redis</li> <li>Generate the witness from the merkle tree database for zkWasm verification</li> <li>Calculate the new merkle tree root when receiving the zkWasm transaction batch for settlement</li> </ul>"},{"location":"getting-started/Quick%20Tutorial.html#1-get-the-zkwasm-mini-rollup-service","title":"1. Get the zkWasm Mini-Rollup service","text":"<p>You can get the zkWasm Mini-Rollup service by cloning the repository: <pre><code>git clone https://github.com/DelphinusLab/zkwasm-mini-rollup.git\ncd zkwasm-mini-rollup\n</code></pre> Or, download the zip file from the Github page and unzip it.</p>"},{"location":"getting-started/Quick%20Tutorial.html#2-start-the-zkwasm-mini-rollup-service","title":"2. Start the zkWasm Mini-Rollup service","text":"<p>In the root directory of the zkWasm Mini-Rollup service, run: <pre><code>docker-compose up\n</code></pre> Make sure your running environment has the permission to access the Docker daemon. This command will start a Docker container named <code>zkwasm-mini-rollup</code>.</p> <p>Note</p> <p>One zkWasm Mini-Rollup service must correspond to one zkWasm rollup application. This will be improved in the future by supporting multiple rollup applications in one service.</p>"},{"location":"getting-started/Quick%20Tutorial.html#step-2-get-the-template-project","title":"Step 2: Get the Template Project","text":"<p>Clone the template project - The Hello World Rollup: <pre><code>git clone https://github.com/riddles-are-us/helloworld-rollup.git\ncd helloworld-rollup\n</code></pre></p> <p>Project Structure</p> <p>The template includes: <pre><code>helloworld-rollup/\n\u251c\u2500\u2500 src/           # Rust source code - for application logic\n\u251c\u2500\u2500 ts/            # TypeScript code - for API testing\n\u251c\u2500\u2500 Cargo.toml     # Rust dependencies\n\u251c\u2500\u2500 Makefile       # Build scripts\n\u2514\u2500\u2500 rust-toolchain # Rust version specification\n</code></pre></p> <p>Install the dependencies for ts: <pre><code>cd ts\nnpm install\n</code></pre></p> <p>After installing the dependencies, compile the ts code: <pre><code>npx tsc\n</code></pre> This will generate the js code in the <code>ts/</code> directory and facilitate the backend server running and testing.</p> <p>Build the project using make: <pre><code>cd ..   #Move to the root directory of the project\nmake build\n</code></pre></p>"},{"location":"getting-started/Quick%20Tutorial.html#step-3-run-the-rollup-application","title":"Step 3: Run the Rollup Application","text":"<p>In the root directory of the project, run: <pre><code>make run\n</code></pre></p> <p>This will start the backend server by running the <code>node ./ts/src/service.js</code>.</p> <p>You shall see some output like the following: <pre><code>rpc bind merkle server: http://127.0.0.1:3030\ninitialize mongoose ...\nstart express server\nServer is running on http://0.0.0.0:3000\nconnecting redis server: localhost\nbootstrapping ... (deploymode: false, remote: false, migrate: false)\nloading wasm application ...\ncheck merkle database connection ...\ninitialize sequener queue ...\nwaiting Count is: 0  perform draining ...\ninitialize application merkle db ...\n</code></pre></p> <p>Congratulations! You have successfully started the zkWasm rollup application. However, in order to build your own rollup application, you need to understand the core components of the zkWasm rollup application.</p>"},{"location":"getting-started/Quick%20Tutorial.html#step-4-the-code-overview","title":"Step 4: The Code Overview","text":"<p>Let's examine the core components of our zkWasm application. This hello world rollup application is structured into several key Rust files, each handling specific functionality. </p>"},{"location":"getting-started/Quick%20Tutorial.html#server-side-code-backend-code","title":"Server Side Code (Backend Code)","text":""},{"location":"getting-started/Quick%20Tutorial.html#main-entry-point-srclibrs","title":"Main Entry Point (<code>src/lib.rs</code>)","text":"<pre><code>use wasm_bindgen::prelude::*;\nuse zkwasm_rest_abi::*;\npub mod config;\npub mod state;\npub mod settlement;\n\nuse crate::config::Config;\nuse crate::state::{State, Transaction};\nzkwasm_rest_abi::create_zkwasm_apis!(Transaction, State, Config);\n</code></pre> <p>The above code includes the following key components:</p> <ul> <li><code>wasm_bindgen</code>: Enables Rust-JavaScript interoperability</li> <li><code>zkwasm_rest_abi</code>: Provides core zkWasm functionality</li> <li><code>create_zkwasm_apis!</code>: Macro that generates necessary API endpoints</li> </ul>"},{"location":"getting-started/Quick%20Tutorial.html#configuration-srcconfigrs","title":"Configuration (<code>src/config.rs</code>)","text":"<pre><code>use serde::Serialize;\n\n#[derive(Serialize, Clone)]\npub struct Config {\n    version: &amp;'static str,\n}\n\nlazy_static::lazy_static! {\n    pub static ref CONFIG: Config = Config {\n        version: \"1.0\"\n    };\n}\n\nimpl Config {\n    pub fn to_json_string() -&gt; String {\n        serde_json::to_string(&amp;CONFIG.clone()).unwrap()\n    }\n\n    pub fn autotick() -&gt; bool {\n        true\n    }\n}\n</code></pre> <p>The <code>Config</code> struct:</p> <ul> <li>Defines application configuration</li> <li>Provides JSON serialization for config values</li> <li>Controls auto-tick behavior - the system will automatically advance its state through tick events, facilitating time-based state transitions in the zkWasm runtime. </li> </ul> <p>Note</p> <p>Currently, the time interval is set to 5 seconds in the server side, which you can modify in the <code>service.ts</code> file in the <code>/src</code> directory of the <code>zkwasm-ts-server</code> package.</p>"},{"location":"getting-started/Quick%20Tutorial.html#settlement-management-srcsettlementrs","title":"Settlement Management (<code>src/settlement.rs</code>)","text":"<pre><code>use zkwasm_rest_abi::WithdrawInfo;\n\npub struct SettlementInfo(Vec&lt;WithdrawInfo&gt;);\npub static mut SETTLEMENT: SettlementInfo = SettlementInfo(vec![]);\n\nimpl SettlementInfo {\n    pub fn append_settlement(info: WithdrawInfo) {\n        unsafe { SETTLEMENT.0.push(info) };\n    }\n\n    pub fn flush_settlement() -&gt; Vec&lt;u8&gt; {\n        zkwasm_rust_sdk::dbg!(\"flush settlement\\n\");\n        let sinfo = unsafe { &amp;mut SETTLEMENT };\n        let mut bytes: Vec&lt;u8&gt; = Vec::with_capacity(sinfo.0.len() * 32);\n        for s in &amp;sinfo.0 {\n            bytes.extend_from_slice(&amp;s.feature.to_le_bytes());\n            bytes.extend_from_slice(&amp;s.address);\n            bytes.extend_from_slice(&amp;s.amount.to_le_bytes());\n        }\n        sinfo.0 = vec![];\n        bytes\n    }\n}\n</code></pre> <p>The <code>SettlementInfo</code> struct:</p> <ul> <li>Handles withdrawal information</li> <li>Converts settlement data to bytes for processing</li> <li>Implements flush mechanism for batch processing</li> </ul> <p>Note</p> <p>In the current architecture of zkWasm Rollup Application, the withdrawal requests from users are handled in the server side. When settlement is triggered, the server will collect all the withdrawals and send them with merkle tree root to the zkWasm protocol contract for verification. </p>"},{"location":"getting-started/Quick%20Tutorial.html#state-management-srcstaters","title":"State Management (<code>src/state.rs</code>)","text":""},{"location":"getting-started/Quick%20Tutorial.html#1-player-data-structure","title":"1. Player Data Structure","text":"<pre><code>#[derive(Debug, Serialize)]\npub struct PlayerData {\n    pub counter: u64,\n}\n\nimpl Default for PlayerData {\n    fn default() -&gt; Self {\n        Self { counter: 0 }\n    }\n}\n\nimpl StorageData for PlayerData {\n    fn from_data(u64data: &amp;mut IterMut&lt;u64&gt;) -&gt; Self {\n        let counter = *u64data.next().unwrap();\n        PlayerData { counter }\n    }\n    fn to_data(&amp;self, data: &amp;mut Vec&lt;u64&gt;) {\n        data.push(self.counter);\n    }\n}\n\npub type HelloWorldPlayer = Player&lt;PlayerData&gt;;\n</code></pre> <p>The <code>PlayerData</code> struct:</p> <ul> <li>Defines player-specific data structure with a <code>counter</code> field</li> <li>Implements <code>Default</code> trait for initializing new players with counter set to 0</li> <li>Implements <code>StorageData</code> trait for data serialization and deserialization</li> <li>Creates a type alias <code>HelloWorldPlayer</code> for Player with PlayerData</li> </ul>"},{"location":"getting-started/Quick%20Tutorial.html#2-state-structure","title":"2. State Structure","text":"<pre><code>#[derive(Serialize)]\npub struct State {\n    counter: u64\n}\n\nimpl State {\n    pub fn get_state(pkey: Vec&lt;u64&gt;) -&gt; String {\n        let player = HelloWorldPlayer::get_from_pid(&amp;HelloWorldPlayer::pkey_to_pid(&amp;pkey.try_into().unwrap()));\n        serde_json::to_string(&amp;player).unwrap()\n    }\n\n    pub fn rand_seed() -&gt; u64 {\n        0\n    }\n\n    pub fn store(&amp;self) {\n    }\n\n    pub fn initialize() {\n    }\n\n    pub fn new() -&gt; Self {\n        State {\n            counter: 0,\n        }\n    }\n\n    pub fn snapshot() -&gt; String {\n        let state = unsafe { &amp;STATE };\n        serde_json::to_string(&amp;state).unwrap()\n    }\n\n    pub fn preempt() -&gt; bool {\n        let state = unsafe { &amp;STATE };\n        return state.counter % 20 == 0; \n    }\n\n    pub fn flush_settlement() -&gt; Vec&lt;u8&gt; {\n        let data = SettlementInfo::flush_settlement();\n        unsafe { STATE.store() };\n        data\n    }\n\n    pub fn tick(&amp;mut self) {\n        self.counter += 1;\n    }\n}\n</code></pre> <p>The <code>State</code> struct:</p> <ul> <li>Maintains global state with a counter field - The counter can be used to track the number of transactions processed</li> <li>Provides methods for state manipulation and querying, such as <code>get_state</code>, <code>store</code></li> <li>Implements serialization for state snapshots</li> <li>Handles settlement flushing and state updates, such as <code>flush_settlement</code></li> </ul> <p>We can also notice that there is a global variable <code>STATE</code> with field <code>counter</code> in the code. This is the state of the zkWasm rollup application, which shall be distinguished from the <code>counter</code> field in the <code>PlayerData</code> struct: <pre><code>pub static mut STATE: State = State {\n    counter: 0\n};\n</code></pre></p>"},{"location":"getting-started/Quick%20Tutorial.html#3-transaction-handler","title":"3. Transaction Handler","text":"<pre><code>pub struct Transaction {\n    pub command: u64,\n    pub data: Vec&lt;u64&gt;,\n}\n\nconst AUTOTICK: u64 = 0;\nconst INSTALL_PLAYER: u64 = 1;\nconst INC_COUNTER: u64 = 2;\n\nconst ERROR_PLAYER_ALREADY_EXIST: u32 = 1;\nconst ERROR_PLAYER_NOT_EXIST: u32 = 2;\n\nimpl Transaction {\n    pub fn decode_error(e: u32) -&gt; &amp;'static str {\n        match e {\n            ERROR_PLAYER_NOT_EXIST =&gt; \"PlayerNotExist\",\n            ERROR_PLAYER_ALREADY_EXIST =&gt; \"PlayerAlreadyExist\",\n            _ =&gt; \"Unknown\"\n        }\n    }\n\n    pub fn decode(params: [u64; 4]) -&gt; Self {\n        let command = params[0] &amp; 0xff;\n        let data = vec![params[1], params[2], params[3]]; // pkey[0], pkey[1], amount\n        Transaction {\n            command,\n            data,\n        }\n    }\n\n    pub fn install_player(&amp;self, pkey: &amp;[u64; 4]) -&gt; u32 {\n        zkwasm_rust_sdk::dbg!(\"install \\n\");\n        let pid = HelloWorldPlayer::pkey_to_pid(pkey);\n        let player = HelloWorldPlayer::get_from_pid(&amp;pid);\n        match player {\n            Some(_) =&gt; ERROR_PLAYER_ALREADY_EXIST,\n            None =&gt; {\n                let player = HelloWorldPlayer::new_from_pid(pid);\n                player.store();\n                0\n            }\n        }\n    }\n\n    pub fn inc_counter(&amp;self, _pkey: &amp;[u64; 4]) -&gt; u32 {\n        todo!()\n    }\n\n    pub fn process(&amp;self, pkey: &amp;[u64; 4], _rand: &amp;[u64; 4]) -&gt; u32 {\n        match self.command {\n            AUTOTICK =&gt; {\n                unsafe { STATE.tick() };\n                return 0;\n            },\n            INSTALL_PLAYER =&gt; self.install_player(pkey),\n            INC_COUNTER =&gt; self.inc_counter(pkey),\n            _ =&gt; {\n                return 0\n            }\n        }\n    }\n}\n</code></pre> <p>The <code>Transaction</code> struct:</p> <ul> <li>Defines transaction structure and command types</li> <li>Handles player installation and counter increment operations (todo)</li> <li>Implements error handling with specific error codes</li> <li>Provides transaction decoding and processing functionality</li> <li>Uses pattern matching for command routing</li> </ul> <p>You may notice that the <code>process</code> method in the <code>Transaction</code> struct is the core method that handles the transaction processing:</p> <p><pre><code>pub fn process(&amp;self, pkey: &amp;[u64; 4], _rand: &amp;[u64; 4]) -&gt; u32 {\n    match self.command {\n        AUTOTICK =&gt; {\n            unsafe { STATE.tick() };\n            return 0;\n        },\n        INSTALL_PLAYER =&gt; self.install_player(pkey),\n        INC_COUNTER =&gt; self.inc_counter(pkey),\n        _ =&gt; {\n            return 0\n        }\n    }\n}\n</code></pre> It receives the transaction command and then routes the transaction to the corresponding handler based on the command. In this case, we have three commands:</p> <ul> <li><code>AUTOTICK</code>: Automatically tick the state of the rollup application, which increments the <code>counter</code> field in the <code>State</code> struct by 1</li> <li><code>INSTALL_PLAYER</code>: Install a new player, which creates a new player with a unique <code>pid</code> and initializes its <code>PlayerData</code></li> <li><code>INC_COUNTER</code>: Increment the counter of a player, which increments the <code>counter</code> field in the <code>PlayerData</code> struct by 1</li> </ul> <p>This process is the core logic of the zkWasm rollup application, which you can refer to implement your own application logic.</p>"},{"location":"getting-started/Quick%20Tutorial.html#client-side-code-frontend-code","title":"Client Side Code (Frontend Code)","text":"<p>The client-side code is written in TypeScript and provides a convenient interface for interacting with the hello world zkWasm rollup application. Let's examine the key components:</p>"},{"location":"getting-started/Quick%20Tutorial.html#constants-and-helper-functions","title":"Constants and Helper Functions","text":"<pre><code>const CMD_INSTALL_PLAYER = 1n;\nconst CMD_INC_COUNTER = 2n;\n\nfunction createCommand(nonce: bigint, command: bigint, feature: bigint) {\n    return (nonce &lt;&lt; 16n) + (feature &lt;&lt; 8n) + command;\n}\n</code></pre> <ul> <li>Two command constants are defined for player installation and counter incrementing</li> <li><code>createCommand</code> helper function constructs command values by combining:<ul> <li><code>nonce</code>: Transaction sequence number</li> <li><code>command</code>: Operation type (install or increment)</li> <li><code>feature</code>: Additional features (currently unused)</li> </ul> </li> </ul> <p>You can customize the <code>createCommand</code> function to pack different types of data based on your application's needs. Here are some examples of how you might modify the bit layout:</p> <ol> <li> <p>Game Commands: <pre><code>// 32 bits nonce + 8 bits gameType + 8 bits playerId + 16 bits command\nfunction createGameCommand(nonce: bigint, gameType: bigint, playerId: bigint, command: bigint) {\n    return (nonce &lt;&lt; 32n) + (gameType &lt;&lt; 24n) + (playerId &lt;&lt; 16n) + command;\n}\n</code></pre></p> </li> <li> <p>Transaction Commands: <pre><code>// 32 bits nonce + 16 bits amount + 8 bits tokenId + 8 bits command\nfunction createTxCommand(nonce: bigint, amount: bigint, tokenId: bigint, command: bigint) {\n    return (nonce &lt;&lt; 32n) + (amount &lt;&lt; 16n) + (tokenId &lt;&lt; 8n) + command;\n}\n</code></pre></p> </li> <li> <p>NFT Commands: <pre><code>// 16 bits nonce + 32 bits tokenId + 8 bits collection + 8 bits command\nfunction createNFTCommand(nonce: bigint, tokenId: bigint, collection: bigint, command: bigint) {\n    return (nonce &lt;&lt; 48n) + (tokenId &lt;&lt; 16n) + (collection &lt;&lt; 8n) + command;\n}\n</code></pre></p> </li> </ol> <p>When designing your command structure, consider:</p> <ul> <li>The size needed for each field</li> <li>Priority and access frequency of fields</li> <li>Future extensibility requirements</li> </ul> <p>Remember to provide corresponding extraction functions for unpacking the data when needed.</p>"},{"location":"getting-started/Quick%20Tutorial.html#player-class","title":"Player Class","text":"<p>The <code>Player</code> class serves as the main interface for interacting with the rollup:</p> <pre><code>export class Player {\n    processingKey: string;\n    rpc: ZKWasmAppRpc;\n\n    constructor(key: string, rpc: string) {\n        this.processingKey = key\n        this.rpc = new ZKWasmAppRpc(rpc);\n    }\n    // ...\n}\n</code></pre> <p>Key methods in the Player class:</p>"},{"location":"getting-started/Quick%20Tutorial.html#1-state-query","title":"1. State Query","text":"<p><pre><code>async getState(): Promise&lt;any&gt; {\n    let state:any = await this.rpc.queryState(this.processingKey);\n    return JSON.parse(state.data);\n}\n</code></pre> The <code>getState</code> method:</p> <ul> <li>Retrieves the current state for a player</li> <li>Returns parsed JSON data containing player information</li> </ul>"},{"location":"getting-started/Quick%20Tutorial.html#2-nonce-management","title":"2. Nonce Management","text":"<pre><code>async getNonce(): Promise&lt;bigint&gt; {\n    let state:any = await this.rpc.queryState(this.processingKey);\n    let nonce = 0n;\n    if (state.data) {\n        let data = JSON.parse(state.data);\n        if (data.player) {\n            nonce = BigInt(data.player.nonce);\n        }\n    }\n    return nonce;\n}\n</code></pre> <p>The <code>getNonce</code> method:</p> <ul> <li>Retrieves the current nonce (transaction sequence number) for a player</li> <li>Essential for transaction ordering and replay protection</li> </ul>"},{"location":"getting-started/Quick%20Tutorial.html#3-player-registration","title":"3. Player Registration","text":"<pre><code>async register() {\n    let nonce = await this.getNonce();\n    try {\n        let result = await this.rpc.sendTransaction(\n            new BigUint64Array([createCommand(nonce, CMD_INSTALL_PLAYER, 0n), 0n, 0n, 0n]),\n            this.processingKey\n        );\n        return result\n    } catch(e) {\n        if (e instanceof Error) {\n            console.log(e.message);\n        }\n    }\n}\n</code></pre> <p>The <code>register</code> method:</p> <ul> <li>Registers a new player in the system</li> <li>Creates and sends an installation transaction</li> <li>Handles potential errors during registration</li> </ul>"},{"location":"getting-started/Quick%20Tutorial.html#4-counter-increment","title":"4. Counter Increment","text":"<pre><code>async incCounter() {\n    let nonce = await this.getNonce();\n    try {\n        let result = await this.rpc.sendTransaction(\n            new BigUint64Array([createCommand(nonce, CMD_INC_COUNTER, 0n), 0n, 0n, 0n]), \n            this.processingKey\n        );\n        return result;\n    } catch(e) {\n        if (e instanceof Error) {\n            console.log(e.message);\n        }\n    }\n}\n</code></pre> <p>The <code>incCounter</code> method:</p> <ul> <li>Increments the player's counter</li> <li>Creates and sends an increment transaction</li> <li>Handles potential errors during the operation</li> </ul>"},{"location":"getting-started/Quick%20Tutorial.html#usage-example","title":"Usage Example","text":"<p>Here's how you might use the client-side API to interact or test with the hello world zkWasm rollup backend, this is also the way to integrate the API into your frontend application:</p> <pre><code>// Initialize a player\nconst player = new Player(\"processingKey\", \"http://localhost:3000\");\n\n// Register the player\nawait player.register();\n\n// Get player state\nconst state = await player.getState();\nconsole.log(\"Player state:\", state);\n\n// Increment counter\nawait player.incCounter();\n</code></pre> <p>Note</p> <p>You may notice that the \"processingKey\" is actually the key for accessing the zkWasm rollup application, it is required and used to sign the data in every transaction to the zkWasm rollup application. In real implementation, you need to generate a processingKey from the user's signature, which is derived from a unique message signed by the user's private key. Please remind your user to keep this key secure and never expose it to the public, as well as never signing a same message with the same private key.</p>"},{"location":"getting-started/Quick%20Tutorial.html#step-5-implementing-your-own-rollup-application","title":"Step 5: Implementing your own Rollup Application","text":"<p>Now that you have a basic understanding of the zkWasm rollup application, you can start to implement your own application by referring to the hello world rollup application.</p> <p>Let's first complete the hello world rollup application by implementing the <code>inc_counter</code> method in <code>src/state.rs</code>. This method increments the <code>counter</code> field in the <code>PlayerData</code> struct by 1. You can use this pattern to implement similar state changes in your own rollup application.</p> <pre><code>pub fn inc_counter(&amp;self, _pkey: &amp;[u64; 4]) -&gt; u32 {\n    // Convert player's public key to player ID\n    let pid = HelloWorldPlayer::pkey_to_pid(_pkey);\n    // Try to get the player instance using the ID\n    let player = HelloWorldPlayer::get_from_pid(&amp;pid);\n\n    // Match on the optional player result\n    match player {\n        // If player exists\n        Some(mut p) =&gt; {\n            // Increment the player's counter\n            p.data.counter += 1;\n            // Store the updated state\n            p.store();\n            // Return 0 to indicate success\n            0\n        },\n        // If player doesn't exist, return error\n        None =&gt; ERROR_PLAYER_NOT_EXIST\n    }\n}\n</code></pre> <p>Let's break down the key components of this implementation:</p>"},{"location":"getting-started/Quick%20Tutorial.html#1-player-identification","title":"1. Player Identification","text":"<p>When you want to access or modify the state of a player, you need to identify the player first. In the hello world rollup application, the player is identified by the player's ID, which is a unique identifier derived from the player's public key.</p> <ul> <li><code>HelloWorldPlayer::pkey_to_pid(_pkey)</code>: Converts the public key to a player ID</li> <li><code>HelloWorldPlayer::get_from_pid(&amp;pid)</code>: Retrieves the player instance using the ID</li> </ul>"},{"location":"getting-started/Quick%20Tutorial.html#2-state-management","title":"2. State Management","text":"<p>Remember that player may not exist, so you need to check if the player exists before accessing or modifying its state.</p> <ul> <li>Uses pattern matching (<code>match</code>) to handle both existing and non-existing player cases</li> <li>For existing players:<ul> <li>Increments the counter: <code>p.data.counter += 1</code></li> <li>Persists the change: <code>p.store()</code></li> <li>Returns 0 to indicate success</li> </ul> </li> <li>For non-existing players:<ul> <li>Returns <code>ERROR_PLAYER_NOT_EXIST</code></li> </ul> </li> </ul>"},{"location":"getting-started/Quick%20Tutorial.html#3-error-handling","title":"3. Error Handling","text":"<ul> <li>Returns appropriate error codes based on the operation result</li> <li>Uses the previously defined <code>ERROR_PLAYER_NOT_EXIST</code> constant</li> </ul> <p>This implementation demonstrates several important patterns for building your own rollup application:</p> <ol> <li>State Access: How to access and modify player-specific state</li> <li>Error Handling: How to handle various edge cases and error conditions</li> <li>State Persistence: How to properly store updated state</li> <li>Player Management: How to handle player existence checks</li> </ol> <p>When implementing your own rollup application, you can follow similar patterns to:</p> <ul> <li>Define your own state structures</li> <li>Implement state modification methods</li> <li>Handle errors appropriately</li> <li>Ensure proper state persistence</li> </ul>"},{"location":"getting-started/Quick%20Tutorial.html#modifying-the-global-state","title":"Modifying the Global State","text":"<p>The global state of the rollup application is maintained in the <code>STATE</code> variable, which is a global variable. When you want to modify the global state, you need to update the <code>STATE</code> variable. For example, in process method in the <code>Transaction</code> struct, we have the following code:</p> <pre><code>match self.command {\n    AUTOTICK =&gt; {\n        unsafe { STATE.tick() };\n        return 0;\n    },\n    ...\n}\n</code></pre> <p>This is the way to modify the global state of the rollup application, and the tick method is defined in the <code>State</code> struct as:</p> <pre><code>pub fn tick(&amp;mut self) {\n    self.counter += 1;\n}\n</code></pre> <p>Remember that any state modifications for players should be:</p> <ul> <li>Atomic and consistent</li> <li>Properly persisted using the <code>store()</code> method</li> <li>Protected with appropriate existence checks</li> <li>Accompanied by proper error handling</li> </ul> <p>However, for Global State, you don't need to consider the existence of players, and you can directly modify the <code>STATE</code> variable as it is defined as mutable.</p> <p>By following these patterns, you can implement various types of state changes in your own rollup application while maintaining consistency and reliability.</p>"},{"location":"getting-started/Quick%20Tutorial.html#step-6-interacting-with-zkwasm-hub","title":"Step 6: Interacting with zkWasm Hub","text":"<p>zkWasm Hub is a hosted cloud service provided by DelphinusLab for finding and sharing zkWasm application images. Using zkWasm Hub, developers can access it using public rest services and create their own private zkWasm space. zkWasm Hub provides automated proving and batching service for applications' workloads with customizable WASM extensions (via WASM host application interfaces). Moreover, users can distribute their GitHub applications onto zkWasm Hub by its auto compilation and updating service. Overall, it provides:</p> <ol> <li>Application image deployment and setup</li> <li>Batching and generating zkWasm proofs for applications</li> </ol> <p>zkWasm Hub operates through a permissionless proving node pool, allowing anyone to participate and provide proving services for applications using the zkWasm cloud service.</p> <p>Note</p> <p>This section aims to provide a easy hands-on way to interact with zkWasm Hub. For more details, please refer to:</p> <ul> <li>zkWasm Service CLI</li> <li>zkWasm Service Helper</li> </ul>"},{"location":"getting-started/Quick%20Tutorial.html#submit-your-rollup-application-image-to-zkwasm-hub","title":"Submit your rollup application image to zkWasm Hub","text":"<p>Let's back to our hello world rollup application, and see how to interact with zkWasm Hub.</p> <p>In the root directory of the hello world rollup application, if you haven't built the modified application, run:</p> <pre><code>make build\n</code></pre> <p>then, we go to the <code>ts</code> directory and run:</p> <pre><code>./publish.sh\n</code></pre> <p>or</p> <pre><code>sh publish.sh\n</code></pre> <p>And you may expect the following output:</p> <pre><code>Begin adding image for  .../helloworld-rollup/ts/node_modules/zkwasm-ts-server/src/application/application_bg.wasm\nmsg is: application_bg.(....)\nRun success.\nsignature is: ...\nget addNewWasmImage response: [object Object]\nAdd Image Response {\n  md5: '...',\n  id: '...'\n}\nFinish addNewWasmImage!\n</code></pre> <p>You shall record the <code>md5</code> value, which will be used when submitting the proof task to zkWasm Hub via your application server.</p>"},{"location":"getting-started/Quick%20Tutorial.html#deploy-your-rollup-application","title":"Deploy your rollup application","text":"<p>Let's back to the root directory of the hello world rollup application, and run: <pre><code>DEPLOY=TRUE IMAGE=\"YOUR_MD5_HASH\" make run\n</code></pre> This will tell the server to automatically submit proof tasks to zkWasm Hub when <code>preempt</code> method (defined in <code>src/state.rs</code>) is triggered. More details about the <code>preempt</code> method please refer to zkWasm Rust SDK.</p> <p>Now we have deployed our rollup application onto zkWasm Hub, and it is ready to be used. You can find the tasks related to your rollup application in the zkWasm Hub Explorer by searching your application md5 hash:</p> <ul> <li>zkWasm Hub Explorer</li> </ul>"},{"location":"getting-started/Quick%20Tutorial.html#restore-the-state","title":"Restore the State","text":"<p>After shutting down and restarting the server or rollup application, you may find that the state has been reset to its initial value. This happens because the server initializes the merkle tree root to the initial value on each startup. There are two ways to restore the state:</p> <ol> <li>Using zkWasm Hub (Recommended)</li> </ol> <p>If you are using zkWasm Hub to generate proofs, start the server with:    <pre><code>DEPLOY=TRUE IMAGE=\"YOUR_MD5_HASH\" REMOTE=TRUE make run\n</code></pre>    This command will retrieve the merkle tree root from the last proof task and restore the state from the rollup database.</p> <ol> <li>Manual Configuration (For Testing)</li> </ol> <p>If you're testing without zkWasm Hub, you can manually set the merkle tree root in <code>ts\\node_modules\\zkwasm-ts-server\\src\\service.js</code>:    <pre><code>let merkle_root = new BigUint64Array([\n    14789582351289948625n,\n    10919489180071018470n,\n    10309858136294505219n,\n    2839580074036780766n,\n]);\n</code></pre></p> <p>You can find your last merkle root in the server terminal output:    <pre><code>wasmdbg:&gt;&gt;&gt;  query root: [14789582351289948625, 10919489180071018470, 10309858136294505219, 2839580074036780766]   \nlast root: BigUint64Array(4) [\n  14789582351289948625n,\n  10919489180071018470n,\n  10309858136294505219n,\n  2839580074036780766n\n]\n</code></pre></p> <p>After setting the merkle root, start the server from the root directory:    <pre><code>make run\n</code></pre></p>"},{"location":"getting-started/Setup%20Environment.html","title":"Setup Environment","text":""},{"location":"getting-started/Setup%20Environment.html#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic knowledge of Rust programming language and Cargo.</li> <li>Basic knowledge of Makefile.</li> <li>Basic knowledge of Docker.</li> <li>Basic knowledge of TypeScript and Node.js.</li> </ul>"},{"location":"getting-started/Setup%20Environment.html#install-make","title":"Install Make","text":"<p>Linux/macOS Users</p> <p>For Unix-based systems, Make is usually pre-installed. If not:</p> <p>Ubuntu/Debian: <pre><code>sudo apt update\nsudo apt install build-essential\n</code></pre></p> <p>macOS: <pre><code>xcode-select --install\n</code></pre></p> <p>Windows Setup for Make</p> <p>Windows users have several options:</p> <ol> <li> <p>Using Chocolatey (Recommended): <pre><code>choco install make\n</code></pre></p> </li> <li> <p>Using MSYS2: <pre><code># First install MSYS2 from https://www.msys2.org/\n# Then open MSYS2 terminal and run:\npacman -S make\n</code></pre></p> </li> <li> <p>Using WSL (Best Option): <pre><code># Install WSL first\nwsl --install\n\n# After WSL is installed, open Ubuntu terminal and run:\nsudo apt update\nsudo apt install build-essential\n</code></pre></p> </li> </ol> <p>Verify Installation</p> <p>After installation, verify Make is properly installed: <pre><code>make --version\n</code></pre></p> <p>Package Manager Installation</p> <p>If you need to install package managers first:</p> <ul> <li>Chocolatey: Installation Guide</li> <li>MSYS2: Download Page</li> <li>WSL: Microsoft Guide</li> </ul> <p>After installing the package manager, make sure you correctly setup the environment variables for the package manager.</p>"},{"location":"getting-started/Setup%20Environment.html#nodejs-setup","title":"Node.js Setup","text":"<p>Install Node.js 18 and npm</p> <p>To install Node.js 18 and npm, follow these steps:</p> <ol> <li>Visit the Node.js download page and download Node.js version 18.x (LTS) for your operating system.</li> <li>Run the installer and follow the setup instructions.</li> <li>Ensure that you check the option to install npm along with Node.js.</li> </ol> <p>Verify Installation</p> <p>After installation, verify Node.js 18, npm, and npx are properly installed: <pre><code>node --version  # Should show v18.x.x\nnpm --version\nnpx --version    # npx comes with npm 5.2.0+\n</code></pre></p> <p>About npx</p> <ul> <li>npx comes bundled with npm version 5.2.0 and higher</li> <li>If npx command is not found, update npm: <pre><code>npm install -g npm@latest\n</code></pre></li> <li>Or install npx explicitly: <pre><code>npm install -g npx\n</code></pre></li> </ul> <p>Note for Windows Users</p> <p>If you encounter issues with permissions or paths, consider using nvm-windows to manage Node.js versions.</p> <p>Using nvm for Node.js 18</p> <p>If you prefer using a version manager, you can use nvm (Node Version Manager) to install Node.js 18:</p> <ul> <li> <p>For macOS/Linux: <pre><code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash\nsource ~/.bashrc\nnvm install 18\nnvm use 18\n</code></pre></p> </li> <li> <p>For Windows, use nvm-windows and follow the installation instructions on the GitHub page: <pre><code>nvm install 18\nnvm use 18\n</code></pre></p> </li> </ul> <p>Package Manager Installation</p> <p>If you need to install package managers first:</p> <ul> <li>Homebrew (macOS): Installation Guide</li> <li>apt (Ubuntu/Debian): Pre-installed, or use:  <pre><code>sudo apt update &amp;&amp; sudo apt install apt\n</code></pre></li> <li>Chocolatey (Windows): Installation Guide</li> </ul>"},{"location":"getting-started/Setup%20Environment.html#rust-setup","title":"Rust Setup","text":"<p>Install Rust</p> <p>If you haven't installed Rust, you can install it using rustup: <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre></p> <p>Verify Installation</p> <p>After installation, verify Rust and Cargo are properly installed: <pre><code>rustc --version\ncargo --version\n</code></pre></p> <p>Note for Windows Users</p> <p>If you're using Windows, we recommend:</p> <ol> <li>Using Windows Subsystem for Linux (WSL)</li> <li>Or installing Rust through the official installer from rustup.rs</li> </ol> <p>Optional: IDE Setup</p> <p>We recommend using VS Code with the following extensions:</p> <ul> <li>rust-analyzer</li> <li>Even Better TOML</li> <li>CodeLLDB</li> </ul> <p>wasm-bindgen Version Requirement</p> <p>For rust project, you must use wasm-bindgen version 0.2.91 (You may check the Cargo.toml / Cargo.lock file in your project for the exact version). Other versions may cause compatibility issues.</p>"},{"location":"getting-started/Setup%20Environment.html#webassembly-tools-setup","title":"WebAssembly Tools Setup","text":""},{"location":"getting-started/Setup%20Environment.html#install-wasm-pack","title":"Install wasm-pack","text":"<p>Install wasm-pack</p> <p>wasm-pack is a tool for building Rust-generated WebAssembly packages. <pre><code># Install wasm-pack using Cargo\ncargo install wasm-pack\n</code></pre></p> <p>Verify Installation</p> <p>After installation, verify wasm-pack is properly installed: <pre><code>wasm-pack --version\n</code></pre></p>"},{"location":"getting-started/Setup%20Environment.html#install-wasm-opt","title":"Install wasm-opt","text":"<p>Install wasm-opt</p> <p>You can install wasm-opt using Cargo: <pre><code>cargo install wasm-opt\n</code></pre></p> <p>Alternatively, you can install it as part of the Binaryen toolkit:</p> <ol> <li>Download from GitHub</li> <li>Extract and add to PATH:</li> </ol> <pre><code>wget https://github.com/WebAssembly/binaryen/releases/download/version_109/binaryen-version_109-x86_64-linux.tar.gz\ntar -xzf binaryen-version_109-x86_64-linux.tar.gz\nexport PATH=$PATH:$(pwd)/binaryen-version_109/bin\n</code></pre> <p>Verify Installation</p> <p>After installation, verify wasm-opt is properly installed: <pre><code>wasm-opt --version\n</code></pre></p>"},{"location":"getting-started/Setup%20Environment.html#docker-setup","title":"Docker Setup","text":"<p>Install Docker</p> <p>Choose your operating system and follow the installation steps:</p> <ol> <li> <p>For Ubuntu/Debian: <pre><code># Remove old versions\nsudo apt-get remove docker docker-engine docker.io containerd runc\n\n# Install dependencies\nsudo apt-get update\nsudo apt-get install \\\n    ca-certificates \\\n    curl \\\n    gnupg \\\n    lsb-release\n\n# Add Docker's official GPG key\nsudo mkdir -m 0755 -p /etc/apt/keyrings\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\n\n# Set up the repository\necho \\\n    \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\\n    $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n\n# Install Docker Engine\nsudo apt-get update\nsudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n</code></pre></p> </li> <li> <p>For macOS:</p> <ul> <li>Download Docker Desktop for Mac</li> <li>Double-click the downloaded <code>.dmg</code> file and drag Docker to Applications</li> <li>Start Docker from Applications</li> </ul> </li> <li> <p>For Windows:</p> <ul> <li>Enable WSL 2 feature</li> <li>Download Docker Desktop for Windows</li> <li>Run the installer and follow the prompts</li> </ul> </li> </ol> <p>Verify Installation</p> <p>After installation, verify Docker is properly installed: <pre><code>docker --version\ndocker compose version\n</code></pre></p> <p>Post-installation Steps</p> <p>To use Docker without sudo (Linux): <pre><code># Create docker group\nsudo groupadd docker\n\n# Add your user to docker group\nsudo usermod -aG docker $USER\n\n# Apply new group membership (or log out and back in)\nnewgrp docker\n</code></pre></p> <p>Test Docker Installation</p> <p>Run a test container: <pre><code>docker run hello-world\n</code></pre></p>"},{"location":"zkwasm-mini-rollup/Rollup%20Convention.html","title":"Convention","text":""},{"location":"zkwasm-mini-rollup/Rollup%20Convention.html#convention-convention","title":"Convention (/convention)","text":"<p>The zkWasm Convention Library provides essential traits and implementations for building zkWasm applications with standardized state management, event handling, and settlement processing. This library serves as the foundation for creating consistent and reliable zkWasm applications.</p>"},{"location":"zkwasm-mini-rollup/Rollup%20Convention.html#core-components","title":"Core Components","text":""},{"location":"zkwasm-mini-rollup/Rollup%20Convention.html#commonstate-trait","title":"CommonState Trait","text":"<p>A fundamental trait that defines the interface for managing application state.</p> <pre><code>pub trait CommonState: Serialize + StorageData + Sized {\n    type PlayerData: StorageData + Default + Serialize;\n    // ... implementation methods\n    // Global State Management\n    fn get_global&lt;'a&gt;() -&gt; Ref&lt;'a, Self&gt;;\n    fn get_global_mut&lt;'a&gt;() -&gt; RefMut&lt;'a, Self&gt;;\n    fn snapshot() -&gt; String\n    // Player State Management\n    fn get_state(pkey: Vec&lt;u64&gt;) -&gt; String \n    // Rand Seed\n    fn rand_seed() -&gt; u64\n    // Rollup State Management\n    fn preempt() -&gt; bool\n    fn store(&amp;self)\n    fn initialize()\n}\n</code></pre> <p>Key Features    </p> <ul> <li>Global State Management: Access and modify global application state</li> <li>Player State Handling: Manage individual player states</li> <li>State Serialization: Convert states to/from JSON format</li> <li>State Persistence: Store and retrieve state from merkle tree storage</li> <li>Rollup State Management: Handle rollup-specific state operations</li> </ul> <p>By implementing this trait, you can ensure that your application adheres to a consistent structure and can be easily integrated with the zkWasm Mini Rollup.</p>"},{"location":"zkwasm-mini-rollup/Rollup%20Convention.html#settlement","title":"Settlement","text":"<p>The code below manages withdrawal information and settlement processing, where <code>append_settlement</code> is used to add a new withdrawal to the list, and <code>flush_settlement</code> process and clear all pending settlements, it returns the transaction data to be sent to the blockchain for settlement.</p> <pre><code>use zkwasm_rest_abi::WithdrawInfo;\n\npub struct SettlementInfo(Vec&lt;WithdrawInfo&gt;);\npub static mut SETTLEMENT: SettlementInfo = SettlementInfo(vec![]);\n\nimpl SettlementInfo {\n    pub fn append_settlement(info: WithdrawInfo) {\n        unsafe { SETTLEMENT.0.push(info) };\n    }\n    pub fn flush_settlement() -&gt; Vec&lt;u8&gt; {\n        zkwasm_rust_sdk::dbg!(\"flush settlement\\n\");\n        let sinfo = unsafe { &amp;mut SETTLEMENT };\n        let mut bytes: Vec&lt;u8&gt; = Vec::with_capacity(sinfo.0.len() * 32);\n        for s in &amp;sinfo.0 {\n            s.flush(&amp;mut bytes);\n        }\n        sinfo.0 = vec![];\n        bytes\n    }\n}\n</code></pre>"},{"location":"zkwasm-mini-rollup/Rollup%20Convention.html#event","title":"Event","text":"<p>Event are used to handle time-based events, such as timers, scheduled actions, or periodic updates, as well as their side effects.</p> <p>There are two things important in the event handling:</p> <ol> <li> <p>The EventHandler Trait defines the interface for handling time-based events</p> <pre><code>pub trait EventHandler: Clone + StorageData {\n    fn get_delta(&amp;self) -&gt; usize; // get the delta time of the event\n    fn progress(&amp;mut self, d: usize); // progress the event by the given delta time\n    fn handle(&amp;mut self, counter: u64) -&gt; Option&lt;Self&gt;; // handle the event and maybe return the next event\n    fn u64size() -&gt; usize; // get the size (fields) of the event type in u64\n}\n</code></pre> </li> <li> <p>The EventQueue Struct: implements a differential time queue (DTQ) for efficient event scheduling and processing.</p> <pre><code>pub struct EventQueue&lt;T: EventHandler + Sized&gt; {\n    pub counter: u64, // the counter of the event queue represents the total number of timeticks.\n    pub list: std::collections::LinkedList&lt;T&gt;, // the event queue\n}\n</code></pre> </li> </ol> <p>In an EventQueue which implements the EventHandler Trait, we have serveral methods to handle the events:</p>"},{"location":"zkwasm-mini-rollup/Rollup%20Convention.html#dump","title":"dump","text":"<p><pre><code>fn dump(&amp;self, counter: u64) {\n    zkwasm_rust_sdk::dbg!(\"dump queue: {}, \", counter);\n    for m in self.list.iter() {\n        let delta = m.get_delta();\n        zkwasm_rust_sdk::dbg!(\" {}\", delta);\n    }\n    zkwasm_rust_sdk::dbg!(\"\\n\");\n}\n</code></pre> The above code is used to dump the event queue, it will print the event queue and the delta of each event. This is useful for debugging and understanding the event queue.</p>"},{"location":"zkwasm-mini-rollup/Rollup%20Convention.html#insert","title":"insert","text":"<pre><code>/// Insert a event into the event queue\n/// The event queue is a differential time queue (DTQ) and the event will\n/// be inserted into its proper position based on its delta time\npub fn insert(&amp;mut self, node: E) {\n    let mut event = node.clone();\n    let mut cursor = self.list.cursor_front_mut();\n    while cursor.current().is_some()\n        &amp;&amp; cursor.current().as_ref().unwrap().get_delta() &lt;= event.get_delta()\n    {\n        event.progress(cursor.current().as_ref().unwrap().get_delta());\n        cursor.move_next();\n    }\n    match cursor.current() {\n        Some(t) =&gt; {\n            t.progress(event.get_delta());\n        }\n        None =&gt; (),\n    };\n\n    cursor.insert_before(event);\n}\n</code></pre> <p>The above code is used to insert a event into the event queue, the event will be inserted into its proper position based on its delta time.</p> <p>Info</p> <p>The event queue is a differential time queue (DTQ), which means in the event queue, the events are sorted by their delta time. For example:</p> <ol> <li>Initial queue state (numbers represent delta time):   <code>[2] -&gt; [3] -&gt; [4]</code></li> <li>When inserting an event with delta=5:   <code>[2] -&gt; [3] -&gt; [4] -&gt; [5]</code></li> <li>When inserting an event with delta=1:   <code>[1] -&gt; [2] -&gt; [3] -&gt; [4] -&gt; [5]</code></li> </ol> <p>Note: The deltas are adjusted during insertion to maintain relative time differences.</p> <p>Key characteristics of DTQ:</p> <ul> <li>Each node stores the time difference from its previous node</li> <li>Total time to an event = sum of deltas from start to that event</li> <li>Efficient for time-based event scheduling</li> <li>Maintains sorted order automatically</li> <li>Updates are O(n) in worst case but typically much faster in practice</li> </ul>"},{"location":"zkwasm-mini-rollup/Rollup%20Convention.html#tick","title":"tick","text":"<p>The <code>tick()</code> method is the core processing function of the event queue, responsible for advancing time and handling events. Each call increments the counter by 1 and processes all due events. </p> <p>The processing flow consists of four main steps:</p> <ol> <li> <p>Retrieve and Process Historical Events</p> <pre><code>/// Perform tick:\n/// 1. get old entries and peform event handlers on each event\n/// 2. insert new generated events into the event queue\n/// 3. handle all events whose counter are zero\n/// 4. insert new generated envets into the event queue\npub fn tick(&amp;mut self) {\n    let counter = self.counter;\n    self.dump(counter);\n    let mut entries_data = self.get_old_entries(counter);\n    let entries_nb = entries_data.len() / E::u64size();\n    let mut dataiter = entries_data.iter_mut();\n    let mut entries = Vec::with_capacity(entries_nb);\n    ....// handle the events\n    self.counter += 1;\n}\n</code></pre> <p>The above code get the historical events data by <code>get_old_entries</code>, and calculate the number of the events by using divide the length of the data by the size of the event type in u64, for example:</p> <pre><code>struct MyEvent {\n    field1: u64,  // takes 1 u64\n    field2: u64,  // takes 1 u64\n}\n\nimpl EventHandler for MyEvent {\n    fn u64size() -&gt; usize {\n        2  // Each MyEvent takes 2 u64s to store\n    }\n    // ... other implementations\n}\n\n// If entries_data contains [1, 2, 3, 4, 5, 6] (6 u64 values)\n// And each MyEvent takes 2 u64s\n// Then entries_nb = 6 / 2 = 3 events\n</code></pre> <p>After getting the number of the events, a entries vector is created to store the historical events.</p> <pre><code>let mut entries = Vec::with_capacity(entries_nb);\nfor _ in 0..entries_nb {\n    entries.push(E::from_data(&amp;mut dataiter));\n}\n</code></pre> <p>Then, the code will iterate over the historical or existing events and call the <code>handle</code> method of each event:  <pre><code>for mut e in entries {\n    let m = e.handle(counter);\n    if let Some(event) = m {\n        self.insert(event);\n    }\n}\n</code></pre></p> </li> <li> <p>Handle the events in the event queue</p> <pre><code>while let Some(head) = self.list.front_mut() {\n    if head.get_delta() == 0 {\n        let m = head.handle(counter);\n        self.list.pop_front();\n        if let Some(event) = m {\n            self.insert(event);\n        }\n    } else {\n        head.progress(1);\n        break;\n    }\n}\n</code></pre> <p>The above code is straightforward and intuitive, it will iterate over the events in the event queue, if the delta of the event is 0, it will call the <code>handle</code> method of the event, probably insert a new event into the event queue (if there is a new event generated), and then pop the event from the event queue. If the delta of the event is not 0, it will progress the event by 1 (the delta of the event will be reduced by 1).</p> </li> </ol> <p>You can also notice that we have other implementations of the <code>EventHandler</code> trait, such as: </p> <pre><code>impl&lt;T: EventHandler + Sized&gt; StorageData for EventQueue&lt;T&gt; {\n    fn to_data(&amp;self, buf: &amp;mut Vec&lt;u64&gt;)\n    fn from_data(u64data: &amp;mut IterMut&lt;u64&gt;) -&gt; Self\n}\n</code></pre> <p>Where <code>to_data</code> is used to convert the event queue to a u64 array and store it in the storage, and <code>from_data</code> is used to convert the u64 array to an event queue from the storage.</p> <p>And:  <pre><code>impl&lt;T: EventHandler + Sized&gt; EventQueue&lt;T&gt;{\n    fn get_old_entries(&amp;self, counter: u64) -&gt; Vec&lt;u64&gt; \n    fn set_entries(&amp;self, entries: &amp;Vec&lt;u64&gt;, counter: u64)\n    pub fn store(&amp;mut self)\n}\n</code></pre></p> <p>Where <code>get_old_entries</code> is used to get the historical events data by the given counter, <code>set_entries</code> is used to set the existing events data by the given counter, and <code>store</code> is used to store the event queue to the storage, which is a merkle key-value pair storage: </p> <pre><code>// In impl&lt;T: EventHandler + Sized&gt; EventQueue&lt;T&gt;{..}\nfn set_entries(&amp;self, entries: &amp;Vec&lt;u64&gt;, counter: u64) {\n    let kvpair = unsafe { &amp;mut MERKLE_MAP };\n    kvpair.set(\n        &amp;[counter &amp; 0xeffffff, EVENTS_LEAF_INDEX, 0, EVENTS_LEAF_INDEX],\n        entries.as_slice(),\n    );\n    zkwasm_rust_sdk::dbg!(\"store {} entries at counter {}\", { entries.len() }, counter);\n}\n</code></pre> <p>The above code can store all the events that shall be processed in a same specific counter to the storage. This is particularly useful to save the memory space and improve the performance.</p> <p>Info</p> <p>We will cover how to leverage the event queue and time-based events in Implementing Time-Driven Events chapter.</p>"},{"location":"zkwasm-mini-rollup/Rollup%20Database.html","title":"Database Service","text":""},{"location":"zkwasm-mini-rollup/Rollup%20Database.html#database-service-dbservice","title":"Database Service (/dbservice)","text":"<p>The Database Service is a crucial component of the zkWasm Mini Rollup system, providing persistent storage and state management for zkWasm applications. It implements a MongoDB-based Merkle tree structure for secure and verifiable state storage, along with JSON-RPC endpoints for state access and modification.</p>"},{"location":"zkwasm-mini-rollup/Rollup%20Database.html#architecture","title":"Architecture","text":"<p>The Database Service consists of three main components:</p> <ol> <li> <p>Merkle Tree Storage</p> <ul> <li>Implements a MongoDB-backed Merkle tree</li> <li>Provides cryptographic verification of state</li> <li>Supports efficient state updates and proofs</li> </ul> </li> <li> <p>Data Hash Records</p> <ul> <li>Stores arbitrary data with hash verification</li> <li>Maintains data integrity through cryptographic hashing</li> <li>Enables efficient data retrieval</li> </ul> </li> <li> <p>JSON-RPC Interface</p> <ul> <li>Exposes state management endpoints</li> <li>Handles concurrent state updates</li> <li>Provides performance metrics</li> </ul> </li> </ol>"},{"location":"zkwasm-mini-rollup/Rollup%20Database.html#core-data-structures","title":"Core Data Structures","text":"<p>The service defines several key data structures for state management: <pre><code>// Request structure for updating Merkle tree leaves\n#[derive(Clone, Deserialize, Serialize)]\npub struct UpdateLeafRequest {\n    root: [u8; 32],      // Current Merkle root\n    data: [u8; 32],      // New leaf data\n    index: String,       // Leaf index (u64 encoded as string)\n}\n\n// Request structure for retrieving Merkle tree leaves\n#[derive(Clone, Deserialize, Serialize)]\npub struct GetLeafRequest {\n    root: [u8; 32],      // Merkle root to query\n    index: String,       // Leaf index to retrieve\n}\n\n// Request structure for storing data records\n#[derive(Clone, Deserialize, Serialize)]\npub struct UpdateRecordRequest {\n    hash: [u8; 32],      // Hash of the data\n    data: Vec&lt;String&gt;,   // Actual data as vector of u64 strings\n}\n\n// Request structure for retrieving data records\n#[derive(Clone, Deserialize, Serialize)]\npub struct GetRecordRequest {\n    hash: [u8; 32],      // Hash of the data to retrieve\n}\n</code></pre></p>"},{"location":"zkwasm-mini-rollup/Rollup%20Database.html#json-rpc-api-endpoints","title":"JSON-RPC API Endpoints","text":"<p>The service exposes several JSON-RPC endpoints for state management:</p>"},{"location":"zkwasm-mini-rollup/Rollup%20Database.html#merkle-tree-operations","title":"Merkle Tree Operations","text":"<pre><code>// Update a leaf in the Merkle tree\nasync fn update_leaf(request: UpdateLeafRequest) -&gt; Result&lt;[u8; 32], Error&gt; {\n    // Parameters:\n    // - root: Current Merkle root\n    // - data: New leaf data\n    // - index: Position to update\n    // Returns:\n    // - New Merkle root after update\n}\n\n// Retrieve a leaf from the Merkle tree\nasync fn get_leaf(request: GetLeafRequest) -&gt; Result&lt;[u8; 32], Error&gt; {\n    // Parameters:\n    // - root: Merkle root to query\n    // - index: Leaf position\n    // Returns:\n    // - Leaf data with proof\n}\n</code></pre>"},{"location":"zkwasm-mini-rollup/Rollup%20Database.html#data-record-operations","title":"Data Record Operations","text":"<pre><code>// Store a new data record\nasync fn update_record(request: UpdateRecordRequest) -&gt; Result&lt;(), Error&gt; {\n    // Parameters:\n    // - hash: Hash of the data\n    // - data: Vector of u64 values as strings\n    // Returns:\n    // - Success/failure status\n}\n\n// Retrieve a data record\nasync fn get_record(request: GetRecordRequest) -&gt; Result&lt;Vec&lt;String&gt;, Error&gt; {\n    // Parameters:\n    // - hash: Hash of the data to retrieve\n    // Returns:\n    // - Vector of u64 values as strings\n}\n</code></pre>"},{"location":"zkwasm-mini-rollup/Rollup%20Host.html","title":"Host Environment","text":""},{"location":"zkwasm-mini-rollup/Rollup%20Host.html#host-environment-host","title":"Host Environment (/host)","text":"<p>The Host Environment provides the foundational runtime infrastructure for zkWasm applications, implementing essential services for cryptographic operations, state management, and WebAssembly integration. It serves as the critical bridge between WebAssembly applications and the underlying system resources. </p> <p>You can find the implementation in the <code>/host</code> directory of the zkWasm Mini Rollup repository. The main components are organized as follows:</p> <pre><code>host/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 context/     // Context management implementations\n\u2502   \u251c\u2500\u2500 jubjub.rs    // Elliptic curve operations\n\u2502   \u251c\u2500\u2500 poseidon.rs  // Hash function implementation\n\u2502   \u2514\u2500\u2500 lib.rs       // Core API and WebAssembly bindings\n</code></pre>"},{"location":"zkwasm-mini-rollup/Rollup%20Host.html#core-context-system","title":"Core Context System","text":"<p>The context system forms the backbone of the Host Environment, managing different execution contexts through thread-safe implementations. Here's how to use the various contexts:</p> <p><pre><code>use std::sync::Mutex;\nuse context::{\n    datacache::CacheContext,\n    jubjub::sum::BabyJubjubSumContext,\n    merkle::MerkleContext,\n    poseidon::PoseidonContext\n};\n\n// Global context initialization\nlazy_static::lazy_static! {\n    // CacheContext: Manages temporary data storage during proof generation\n    pub static ref DATACACHE_CONTEXT: Mutex&lt;CacheContext&gt; = Mutex::new(CacheContext::new());\n\n    // MerkleContext: Handles state tree operations for your application's state\n    pub static ref MERKLE_CONTEXT: Mutex&lt;MerkleContext&gt; = Mutex::new(MerkleContext::new(0));\n\n    // PoseidonContext: Provides cryptographic hash functions for state commitment\n    pub static ref POSEIDON_CONTEXT: Mutex&lt;PoseidonContext&gt; = Mutex::new(PoseidonContext::default(0));\n\n    // JubjubContext: Manages elliptic curve operations for signatures\n    pub static ref JUBJUB_CONTEXT: Mutex&lt;BabyJubjubSumContext&gt; = Mutex::new(BabyJubjubSumContext::default(0));\n}\n</code></pre> These contexts are thread-safe and globally accessible throughout your application's runtime.</p>"},{"location":"zkwasm-mini-rollup/Rollup%20Host.html#data-cache-operations","title":"Data Cache Operations","text":"<p>The data cache system provides temporary storage during proof generation:</p> <pre><code>#[wasm_bindgen]\npub fn cache_set_mode(mode: u64) {\n    // Set the cache mode: STORE_MODE for writing, READ_MODE for reading\n    DATACACHE_CONTEXT.lock().unwrap().set_mode(mode);\n}\n\n#[wasm_bindgen]\npub fn cache_store_data(data: u64) {\n    // Store a piece of data in the cache\n    DATACACHE_CONTEXT.lock().unwrap().store_data(data);\n}\n\n#[wasm_bindgen]\npub fn cache_fetch_data() -&gt; u64 {\n    // Retrieve data from the cache\n    DATACACHE_CONTEXT.lock().unwrap().fetch_data()\n}\n</code></pre>"},{"location":"zkwasm-mini-rollup/Rollup%20Host.html#state-management-and-cryptographic-operations","title":"State Management and Cryptographic Operations","text":""},{"location":"zkwasm-mini-rollup/Rollup%20Host.html#poseidon-hash-operations","title":"Poseidon Hash Operations","text":"<pre><code>#[wasm_bindgen]\npub fn poseidon_new(arg: u64) {\n    // Initialize a new Poseidon hash computation\n    // arg: size of the input to be hashed\n    POSEIDON_CONTEXT.lock().unwrap().poseidon_new(arg as usize);\n}\n\n#[wasm_bindgen]\npub fn poseidon_push(arg: u64) {\n    // Add a value to the current hash computation\n    // Used to build up the state that needs to be hashed\n    POSEIDON_CONTEXT.lock().unwrap().poseidon_push(arg);\n}\n\n#[wasm_bindgen]\npub fn poseidon_finalize() -&gt; u64 {\n    // Complete the hash computation and return the result\n    // The hash can be used as a commitment to the state\n    POSEIDON_CONTEXT.lock().unwrap().poseidon_finalize()\n}\n</code></pre>"},{"location":"zkwasm-mini-rollup/Rollup%20Host.html#merkle-tree-state-management","title":"Merkle Tree State Management","text":"<pre><code>#[wasm_bindgen]\npub fn merkle_setroot(arg: u64) {\n    // Set the root of the Merkle tree\n    // Used when initializing your application's state\n    MERKLE_CONTEXT.lock().unwrap().set_root(arg);\n}\n\n#[wasm_bindgen]\npub fn merkle_get() -&gt; u64 {\n    // Get the current value at the selected Merkle tree node\n    // Used to read state values from your application\n    MERKLE_CONTEXT.lock().unwrap().get()\n}\n\n#[wasm_bindgen]\npub fn merkle_set(arg: u64) {\n    // Update a value in the Merkle tree\n    // Used when your application modifies its state\n    MERKLE_CONTEXT.lock().unwrap().set(arg);\n}\n</code></pre> <p>Info</p> <p>For host functions, you can also refer to zkWasm Overview</p>"},{"location":"zkwasm-mini-rollup/Rollup%20Overview.html","title":"zkWasm Mini Rollup Overview","text":"<p>As a rest service, zkWasm Mini Rollup provides a way for transaction handling and state management (i.e. Database service) for zkWasm server side applications. </p> <p>You may have delved into the details of how its ABI constructs the execution flow of rollup through zkWasm Rust SDK. Now we will walk through other implementation details of zkWasm Mini Rollup.</p>"},{"location":"zkwasm-mini-rollup/Rollup%20Overview.html#zkwasm-mini-rollup-package-structure","title":"zkWasm Mini Rollup Package Structure","text":"<p>Remind that zkWasm Mini Rollup Repository is a monorepo that contains multiple packages:</p> <pre><code>- ABI (Application Binary Interface)\n  - Location: /abi\n  - Purpose: Defines the interface between the WASM application and the host environment\n  - Key Features:\n    - Implements the bundled logic within the zkmain function\n    - Handles transaction verification and processing\n    - Manages state transitions and merkle tree operations\n\n- Host Environment\n  - Location: /host\n  - Purpose: Provides the runtime environment for the WASM application\n  - Components:\n    - WASM bootstrap implementation\n    - Host API interfaces\n    - Runtime service management\n\n- Database Service\n  - Location: /dbservice\n  - Purpose: Manages data persistence and state management\n  - Features:\n    - Database interface implementations\n    - State management utilities\n    - Data persistence layer\n\n- TypeScript Server Implementation\n  - Location: /ts\n  - Purpose: Frontend toolkit and service implementation\n  - Components:\n    - REST service implementation\n    - WASM bootstrapping\n    - Worker thread management\n\n- Convention\n  - Location: /convention\n  - Purpose: Defines shared utilities for application development\n  - Contents:\n    - Common interfaces\n    - Shared types and constants\n    - Project-wide utilities\n</code></pre> <p>As we have covered the ABI in zkWasm Rust SDK, we will focus on the other packages.</p>"},{"location":"zkwasm-mini-rollup/Rollup%20Server.html","title":"Server Implementation (zkWasm-ts-Server)","text":""},{"location":"zkwasm-mini-rollup/Rollup%20Server.html#server-implementation-zkwasm-ts-server-ts","title":"Server Implementation (zkWasm-ts-Server) (/ts)","text":"<p>The Server implementation serves as the service layer of the zkWasm Mini Rollup system, providing essential functionality for application bootstrapping, transaction processing, proof generation, and service management. This implementation bridges the gap between client applications and the underlying zkWasm infrastructure. </p>"},{"location":"zkwasm-mini-rollup/Rollup%20Server.html#core-service-architecture-tsservicets","title":"Core Service Architecture (ts/service.ts)","text":"<p>The Service layer is organized into several key components that work together to provide a complete rollup service:</p> <ul> <li>Transaction batch processing and scheduling</li> <li>State synchronization between different system components</li> <li>Service lifecycle management including startup and shutdown</li> <li>Error handling and recovery mechanisms</li> </ul> <p>Let's take a look at the core implementation of the service layer service.ts. This file contains the main logic for starting and running the zkWasm Mini Rollup Appication. </p> <p>Remind how to run the zkWasm Mini Rollup Application, you can find the example code in the helloworld-rollup:</p> <pre><code>import { Service } from \"zkwasm-ts-server\";\nconst service = new Service(() =&gt; { return; });\nservice.initialize();\nservice.serve();\n</code></pre> <p>We can notice that the <code>Service</code> class is instantiated at first, here's how the <code>Service</code> class is defined:</p> <pre><code>export class Service {\n    worker: null | Worker;\n    queue: null | Queue;\n    txCallback: (arg: TxWitness) =&gt; void;\n\n    constructor(cb: (arg: TxWitness) =&gt; void) {\n        this.worker = null;\n        this.queue = null;\n        this.txCallback = cb;\n    }\n}\n</code></pre> <p>The Service class is the core orchestrator for the zkWasm Mini Rollup system. It manages transaction processing, job queuing, and callback handling through a worker-based architecture, here's the explanation of the components:</p> <ol> <li> <p>Worker Management (worker: null | Worker)</p> <ul> <li>Purpose: Handles computationally intensive tasks like proof generation</li> <li>Type: Worker from the bullmq package</li> <li>Initially set to null and initialized during service startup</li> <li>Used for:<ul> <li>Running proof generation tasks in the background</li> <li>Processing transactions asynchronously</li> <li>Managing computational resources</li> </ul> </li> </ul> </li> <li> <p>Queue Management (queue: null | Queue)</p> <ul> <li>Purpose: Manages transaction processing order and scheduling</li> <li>Type: Queue from the bullmq package</li> <li>Initially set to null and initialized during service startup</li> <li>Used for:<ul> <li>Maintaining transaction order</li> <li>Ensuring sequential processing</li> <li>Managing backpressure</li> </ul> </li> </ul> </li> <li> <p>Transaction Callback (txCallback: (arg: TxWitness) =&gt; void)</p> <ul> <li>Purpose: Handles post-transaction processing notifications</li> <li>Type: Function that takes a TxWitness argument</li> <li>Called after successful transaction processing</li> <li>Used for:<ul> <li>Notifying external systems of transaction completion</li> <li>Triggering state updates</li> <li>Handling transaction-specific logic</li> </ul> </li> </ul> </li> </ol> <p>After the Service class is instantiated, the <code>initialize</code> method is called, which sets up necessary connections and bootstraps the application: <pre><code>async initialize() {\n    // Connect to MongoDB\n    await mongoose.connect(get_mongoose_db());\n\n    const db = mongoose.connection; \n    // Handle connection error\n    db.on('error', () =&gt; {\n      console.error('fatal: mongoose connection error ... process will terminate');\n      process.exit(1);\n    });\n    // Handle connection success\n    db.once('open', () =&gt; {\n      console.log('Connected to MongoDB');\n    });\n\n    // Setup Redis connection\n    const connection = new IORedis(\n      {\n        host: redisHost,  // Your Redis server host\n        port: 6379,        // Your Redis server port\n        reconnectOnError: (err) =&gt; {\n          console.log(\"reconnect on error\", err);\n          return true;\n        },\n        maxRetriesPerRequest: null  // Important: set this to null\n      }\n    );\n\n    // Bootstrap application\n    await initBootstrap();\n    await initApplication(bootstrap);\n}\n</code></pre></p> <p>It bootstraps WASM by implementing zkWasm's host interfaces which are another WASM image that is preloaded before loading the main WASM image. The implementation of these host APIs can be found in ts/src/bootstrap/ which is compiled from the rust bootstrap code in host directory.</p>"},{"location":"zkwasm-mini-rollup/Rollup%20Server.html#bootstrap-tsbootstrap","title":"Bootstrap (ts/bootstrap)","text":"<p>The Bootstrap process, as mentioned above, serves as the critical bridge between the service layer and the WebAssembly-based host environment. It provides the necessary bindings and initialization logic to enable seamless communication between different components.</p> <pre><code>bootstrap/\n\u251c\u2500\u2500 bootstrap.d.ts     # TypeScript definitions for WASM bindings\n\u251c\u2500\u2500 bootstrap.js       # Main bootstrap implementation\n\u251c\u2500\u2500 bootstrap_bg.wasm  # WebAssembly binary\n\u251c\u2500\u2500 dbprocess.ts      # Database processing utilities\n\u2514\u2500\u2500 rpcbind.js        # RPC binding implementation\n</code></pre>"},{"location":"zkwasm-mini-rollup/Rollup%20Server.html#host-function-bindings","title":"Host Function Bindings","text":"<p>The bootstrap directly interfaces with the host environment (/host directory) by providing TypeScript bindings for the core host functions:</p> <pre><code>// Host function bindings examples\nexport function cache_set_mode(mode: bigint): void;\nexport function cache_store_data(data: bigint): void;\nexport function cache_fetch_data(): bigint;\n</code></pre> <p>These bindings correspond to the Rust implementations in the host environment:</p> <pre><code>// In host/src/lib.rs\n#[wasm_bindgen]\npub fn cache_set_mode(mode: u64) { ... }\npub fn cache_store_data(data: u64) { ... }\npub fn cache_fetch_data() -&gt; u64 { ... }\n</code></pre> <p>And the bootstrap will be compiled into WASM binary and preloaded before loading the main WASM image to provide the host functions for the application.</p>"},{"location":"zkwasm-mini-rollup/Rollup%20Server.html#database-operations","title":"Database Operations","text":"<p>The zkWasm Mini Rollup system implements a multi-layered RPC architecture for database operations, consisting of three main components:</p> <ol> <li> <p>RPC Binding Layer (rpcbind.js)</p> <pre><code>// High-level interface exposing database operations\nexport function get_leaf(root, index) { ... }  // Retrieve a leaf node from the Merkle tree\nexport function update_leaf(root, index, data) { ... }  // Update a leaf node in the Merkle tree\nexport function get_record(hash) { ... }  // Retrieve a record by its hash\nexport function update_record(hash, data) { ... }  // Update a record's data\n</code></pre> <p>This layer provides high-level functions for database operations with built-in performance monitoring. Each function formats the JSON-RPC request and delegates to syncrpc.cjs through the <code>requestMerkleData</code> function.</p> </li> <li> <p>Synchronous RPC Layer (syncrpc.cjs)</p> <pre><code>function requestMerkleData(requestData) {\n    // Manages a persistent Node.js child process running dbprocess.js\n    // Handles synchronous IPC communication\n}\n</code></pre> <p>This intermediate layer maintains a persistent Node.js child process running dbprocess.js. It implements synchronous inter-process communication (IPC) using file descriptors for reliable data exchange.</p> </li> <li> <p>Database Process Layer (dbprocess.ts)</p> <pre><code>export class MerkleServiceRpc {\n    private baseUrl: string;\n    private instance;\n\n    constructor(baseUrl: string) {\n        this.baseUrl = baseUrl;\n        this.instance = axios.create({\n            baseURL: this.baseUrl,\n            headers: { 'Content-Type': 'application/json' }\n        });\n    }\n\n    public async queryDB(request: any): Promise&lt;void&gt; {\n        // Handles actual HTTP communication with the Merkle tree database service\n    }\n}\n</code></pre> <p>This layer runs as a separate process and handles the actual HTTP communication with the Merkle tree database service. It processes JSON-RPC requests and manages the HTTP connection pool.</p> </li> </ol> <p>Communication Flow</p> <ol> <li>Client code calls exported functions from rpcbind.js</li> <li>rpcbind.js formats the JSON-RPC request and calls requestMerkleData from syncrpc.cjs</li> <li>syncrpc.cjs writes the request to the child process's stdin and waits for response on stdout</li> <li>dbprocess.ts receives the request through stdin, makes an HTTP request to the Merkle service, and writes the response back to stdout</li> <li>The response flows back through the layers to the original caller</li> </ol> <p>Remind that we initialize the application by:</p> <pre><code>await initBootstrap();\nawait initApplication(bootstrap);\n</code></pre> <p>This will allow the application to use the specific WebAssembly module and the infrastructure provided by the bootstrap module.</p>"},{"location":"zkwasm-mini-rollup/Rollup%20Server.html#server-configuration-tsservicets","title":"Server Configuration (ts/service.ts)","text":"<p>After bootstrapping the application, the initialization process checks the environment variables.</p> <p>We have five environment variables that can be set to configure the server:</p> <ol> <li><code>process.env.DEPLOY</code>: set to <code>TRUE</code> if you want to interact with the zkWasm hub such as submitting tasks for your application.</li> <li><code>process.env.REMOTE</code>: set to <code>TRUE</code> if you want to get the latest merkle root from the latest proof generated by the zkWasm hub for your application.</li> <li><code>process.env.MIGRATE</code>: set to <code>TRUE</code> if you have upgraded your application and need to migrate your data.</li> <li><code>process.env.REDISHOST</code>: the host of the Redis server.</li> <li><code>process.env.TASKID</code>: the task id of your application, used for retrieving the latest proof generated by the zkWasm hub for your application.</li> </ol> <p>You can refer to the Restore the State section in Quick Tutorial for more details about using these environment variables. You can either add those variables in the <code>.env</code> file or set them directly when you run the application in the terminal.</p>"},{"location":"zkwasm-mini-rollup/Rollup%20Server.html#migrate","title":"Migrate","text":"<p>First, the initialization process checks if the <code>migrate</code> environment variable is set to <code>TRUE</code>. If it is, it will proceed to migrate the data using the lastest merkle root from the proxy contract (the main contract of the zkWasm Protocol Contracts).</p> <pre><code>if (migrate) {\n    if (remote) {throw Error(\"Can't migrate in remote mode\");} // Can't migrate in remote mode because you have updated your application which has a different image hash.\n    merkle_root = await getMerkleArray(); // Get the merkle root from the proxy contract.\n    console.log(\"Migrate: updated merkle root\", merkle_root);\n}\n</code></pre> <p>This will retrieve the lastest merkle root from the proxy contract via the <code>getMerkleArray</code> function:</p> <pre><code>export async function getMerkleArray(): Promise&lt;BigUint64Array&gt;{\n  // Connect to the Proxy contract\n  const proxy = new ethers.Contract(constants.proxyAddress, abiData.abi, provider);\n  // Fetch the proxy information\n  let proxyInfo = await proxy.getProxyInfo();\n  // Extract the old Merkle root\n  const oldRoot = proxyInfo.merkle_root;\n\n  return convertToBigUint64Array(oldRoot);\n}\n</code></pre> <p>In order to use the <code>getMerkleArray</code> function for migration, you need to set two more environment variables:</p> <ol> <li><code>process.env.SETTLEMENT_CONTRACT_ADDRESS</code>: the address of the proxy contract.</li> <li><code>process.env.RPC_PROVIDER</code>: the rpc provider of the blockchain that the proxy contract is deployed on.</li> </ol>"},{"location":"zkwasm-mini-rollup/Rollup%20Server.html#restore","title":"Restore","text":"<p>After the migration check, the initialization process will check if the <code>remote</code> environment variable is set to <code>TRUE</code>. If it is, it will proceed to restore the data using the lastest merkle root from the latest proof generated by the zkWasm hub for your application. </p> <pre><code>if (remote) {\n    while (true) { // Keep waiting until there are no uncompleted tasks on the zkWasm hub.\n        const hasTasks = await has_uncomplete_task(); // Check if there are any uncompleted tasks on the zkWasm hub.\n        if (hasTasks) \n            {\n                console.log(\"remote = 1, There are uncompleted tasks. Trying again in 5 second...\");\n                await new Promise(resolve =&gt; setTimeout(resolve, 5000)); // Sleep for 5 second\n            } else {\n                console.log(\"remote = 1, No incomplete tasks. Proceeding...\");\n                break; // Exit the loop if there are no incomplete tasks\n            }\n    }\n\n    let task = await get_latest_proof(taskid); // Get the latest proof from the zkWasm hub.\n    if (task) {\n        const instances = ZkWasmUtil.bytesToBN(task?.instances);\n        merkle_root = new BigUint64Array([\n            BigInt(instances[4].toString()),\n            BigInt(instances[5].toString()),\n            BigInt(instances[6].toString()),\n            BigInt(instances[7].toString()),\n        ]);\n    }\n}\n</code></pre> <p>After the restore check, we could initialize the application with the merkle root, which will be used to restore or initialize the state of the application.</p> <pre><code>application.initialize(merkle_root);\n</code></pre>"},{"location":"zkwasm-mini-rollup/Rollup%20Server.html#sequencer","title":"Sequencer","text":"<p>After the initialization process, the server will start the sequencer to process the transactions. To ensure the state consistency and clean start of the server, the sequencer queue will be drained to prevent any previous tasks from being processed which may cause unexpected state.</p> <pre><code>const myQueue = new Queue('sequencer', {connection});\nconst waitingCount = await myQueue.getWaitingCount();\nconsole.log(\"waiting Count is:\", waitingCount, \" perform draining ...\");\nawait myQueue.drain();\nthis.queue = myQueue;\n</code></pre> <p>Info</p> <p>What is a Sequencer?</p> <p>A sequencer is a component that manages the order of transactions in a blockchain or distributed system. It ensures that transactions are processed in a sequential manner, maintaining the integrity and consistency of the system's state.</p>"},{"location":"zkwasm-mini-rollup/Rollup%20Server.html#timetick-transaction","title":"Timetick transaction","text":"<p>The sequencer handles the timetick function for the application. Timetick is a special type of system transaction that is automatically generated at regular intervals to drive time-dependent state transitions in the application. It can be used in time-related applications such as Game, DeFi (for interest calculations), or any application that requires periodic state updates.</p> <pre><code>// Check if application needs automatic ticking\nif (application.autotick()) {\n    // Generate timetick transaction every 5 seconds\n    setInterval(async () =&gt; {\n        try {\n            await myQueue.add('autoJob', {command:0});\n        } catch (error) {\n            console.error('Error adding automatic job to the queue:', error);\n            process.exit(1);\n        }\n    }, 5000); // This can be set to any interval you want, the default is 5 seconds.\n}\n</code></pre> <p>Info</p> <p>By default, the timetick interval is set to 5 seconds, you can change it here at the moment, we will provider better setting for the timetick interval in the future.</p>"},{"location":"zkwasm-mini-rollup/Rollup%20Server.html#transaction-processing-worker-implementation","title":"Transaction Processing Worker Implementation","text":"<p>The sequencer worker serves as the core transaction processing engine in our zkWasm Mini Rollup system. It operates on a Redis-backed queue system using BullMQ (which you have seen in the Sequencer main section), processing two distinct types of transactions:</p> <ol> <li>automatic timetick transactions, specified by <code>autoJob</code> (which we have mentioned in the Timetick transaction section)</li> <li>user-submitted transactions, specified by <code>transaction</code></li> </ol>"},{"location":"zkwasm-mini-rollup/Rollup%20Server.html#automatic-timetick-transaction-flow","title":"Automatic Timetick Transaction Flow","text":"<pre><code>if (job.name == 'autoJob') {\n    try {\n        let rand = await generateRandomSeed(); // Returns a seed commitment\n        let oldSeed = application.randSeed(); // Returns the previous seed commitment\n        let seed = 0n;\n        if (oldSeed != 0n) { // If there is a previous seed commitment\n            const randRecord = await modelRand.find({\n                commitment: oldSeed.toString(),\n            });\n            seed = randRecord[0].seed!.readBigInt64LE(); // Retrieve the previous seed from the database\n        };\n        let signature = sign(new BigUint64Array([0n, seed, rand, 0n]), get_server_admin_key()); // Create an admin-signed transaction combining the seed and the generated commitment\n        let u64array = signature_to_u64array(signature);\n        application.handle_tx(u64array); // Execute the transaction in local\n        await this.install_transactions(signature, job.id); //Install transaction into rollup\n    } catch (error) {\n        console.log(\"fatal: handling auto tick error, process will terminate.\", error);\n        process.exit(1);\n    }\n}\n</code></pre> <p>When processing an autoJob, the system follows these steps:</p> <ol> <li>Generates a new random seed and returns its commitment.</li> <li>If there is a previous seed commitment, retrieves the previous seed.</li> <li>Creates an admin-signed transaction combining the seed and the generated commitment.</li> <li>Executes the transaction and updates the system state</li> </ol>"},{"location":"zkwasm-mini-rollup/Rollup%20Server.html#user-transaction-flow","title":"User Transaction Flow","text":"<pre><code>if (job.name == 'transaction') {\n    console.log(\"handle transaction ...\");\n    try {\n        let signature = job.data.value; // Get the transaction signature\n        let u64array = signature_to_u64array(signature);\n        console.log(\"tx data\", signature);\n        application.verify_tx_signature(u64array); // Verify the transaction signature\n        let error = application.handle_tx(u64array); // Execute the transaction\n        if (error == 0) {\n            // make sure install transaction will succeed\n            await this.install_transactions(signature, job.id);\n            try {\n                const jobRecord = new modelJob({\n                    jobId: signature.sigx,\n                    message: signature.message,\n                    result: \"succeed\",\n                });\n                await jobRecord.save();\n            } catch (e) {\n                console.log(\"Error: store transaction job error\");\n                throw e\n            }\n        } else {\n            let errorMsg = application.decode_error(error); // Decode the transaction error\n            throw Error(errorMsg)\n        }\n        console.log(\"done\");\n        const pkx = new LeHexBN(job.data.value.pkx).toU64Array();\n        let jstr = application.get_state(pkx); // Get the updated player state\n        let player = JSON.parse(jstr); // Parse the state into a JSON object\n        let result = {\n            player: player,\n            state: snapshot\n        }; // Return the updated player state and system snapshot\n        return result\n    } catch (e) {\n        throw e\n    }\n}\n</code></pre> <p>For user-submitted transactions, the process includes:</p> <ol> <li>Signature verification using application-specific logic</li> <li>Transaction execution with error checking</li> <li>State updates and job record maintenance</li> <li>Return of updated player state and system snapshot</li> </ol> <p>The system maintains transaction atomicity through careful error handling and database transaction management.</p>"},{"location":"zkwasm-mini-rollup/Rollup%20Server.html#transaction-installation-rollup","title":"Transaction Installation (Rollup)","text":"<p>After verifying the signature, the sequencer will install the transaction into the rollup. Let's delve into the <code>install_transactions</code> function.</p> <p>The function begins by adding the transaction to the witness array and triggering necessary callbacks:</p> <p><pre><code>transactions_witness.push(tx);\nthis.txCallback(tx);\nsnapshot = JSON.parse(application.snapshot());\n</code></pre> This process captures the current state and prepares for persistence. The transaction is then stored in the database using a dedicated transaction model: <pre><code>const txRecord = new modelTx(tx);\ntxRecord.save();\n</code></pre> When the rollup reaches its preemption point, indicating a batch is ready for processing, the system initiates the proof generation process:</p> <pre><code>if (application.preempt()) {\n    console.log(\"rollup reach its preemption point, generating proof:\");\n    let txdata = application.finalize(); // This will perform flush_settlement and return the transaction data\n    ...\n}\n</code></pre> <p>In deployment mode, the system submits the proof task and creates a bundle record linking the Merkle root with the task ID:</p> <pre><code>let task_id = await submitProofWithRetry(merkle_root, transactions_witness, txdata);\nconst bundleRecord = new modelBundle({\n    merkleRoot: merkleRootToBeHexString(merkle_root),\n    taskId: task_id,\n});\n</code></pre> <p>After successful task submission, the system performs a complete state reset through the updated merkle root:</p> <pre><code>transactions_witness = new Array();\nmerkle_root = application.query_root();\nawait (initApplication as any)(bootstrap);\napplication.initialize(merkle_root);\n</code></pre>"},{"location":"zkwasm-mini-rollup/Rollup%20Server.html#serve-endpoints-tsservicets","title":"Serve Endpoints (ts/service.ts)","text":"<p>Once the main WASM application is initialized, we start the minirollup PRC server using nodejs express. It contains four endpoints.</p> <ol> <li> <p>query: This endpoint allows user to query their current state and the game public state: <pre><code>app.post('/query', async (req, res) =&gt; {\n    const value = req.body;\n    if (!value) {\n        return res.status(400).send('Value is required');\n    }\n    try {\n        const pkx = new LeHexBN(value.pkx).toU64Array();\n        let u64array = new BigUint64Array(4);\n        u64array.set(pkx);\n        let jstr = application.get_state(pkx);   // here we use the get_state function from application wasm binary\n        let player = JSON.parse(jstr);\n        let result = {\n            player: player,\n            state: snapshot\n        };\n        res.status(201).send({\n            success: true,\n            data: JSON.stringify(result),\n        });\n    }\n    catch (error) {\n        res.status(500).send('Get Status Error');\n    }\n});\n</code></pre></p> </li> <li> <p>send: An endpoint handles user transactions. <pre><code>app.post('/send', async (req, res) =&gt; {\n    const value = req.body;\n    if (!value) {\n        return res.status(400).send('Value is required');\n    }\n    try {\n        const msg = new LeHexBN(value.msg);\n        const pkx = new LeHexBN(value.pkx);\n        const pky = new LeHexBN(value.pky);\n        const sigx = new LeHexBN(value.sigx);\n        const sigy = new LeHexBN(value.sigy);\n        const sigr = new LeHexBN(value.sigr);\n        if (verify_sign(msg, pkx, pky, sigx, sigy, sigr) == false) {\n            res.status(500).send('Invalid signature');\n        }\n        else {\n            const job = await myQueue.add('transaction', { value });\n            res.status(201).send({\n                success: true,\n                jobid: job.id\n            });\n        }\n    }\n    catch (error) {\n        res.status(500).send('Failed to add job to the queue');\n    }\n});\n</code></pre> This endpoint will add transactions into the global job sequencer where each job is handled via the exposed wasm function <code>handle_tx</code>, which then calls the \"process\" function in the application.</p> </li> <li> <p>config: An endpoint that returns all static configuration of the application. <pre><code>app.post('/config', async (req, res) =&gt; {\n    try {\n        let jstr = application.get_config();\n        res.status(201).send({\n            success: true,\n            data: jstr\n        });\n    }\n    catch (error) {\n            res.status(500).send('Get Status Error');\n        }\n    });\n</code></pre></p> </li> <li> <p>jobId: An endpoint allows user to query the job information by jobId. <pre><code>app.get('/job/:id', async (req, res) =&gt; {\n    try {\n        let jobId = req.params.id;\n        const job = await Job.fromId(this.queue!, jobId);\n        return res.status(201).json(job);\n    } catch (err) {\n        // job not tracked\n        console.log(err);\n        res.status(500).json({ message: (err as Error).toString()});\n    }\n});\n</code></pre></p> </li> </ol> <p>Those endpoints are wrapped into RPC methods in ts/src/rpc.ts which can be used by any client to interact with the zkWasm Mini Rollup Application and you can find usage examples in Quick Tutorial.</p>"},{"location":"zkwasm-mini-rollup/Rollup%20Server.html#server-admin-operations-tsinit_adminjs","title":"Server Admin Operations (ts/init_admin.js)","text":"<p>When changing the state of the rollup, some operations are only allowed for the server admin. For example, only the admin can perform timetick or deposit functions.</p> <p>In your root directory, you can add the .env file which can specify the admin private key as:</p> <pre><code>SERVER_ADMIN_KEY = YOUR_ADMIN_PRIVATE_KEY\n</code></pre> <p>In the Makefile of helloworld rollup, you can find the following commands:</p> <pre><code>./src/admin.pubkey: ./ts/node_modules/zkwasm-ts-server/src/init_admin.js\n    node ./ts/node_modules/zkwasm-ts-server/src/init_admin.js ./src/admin.pubkey\n</code></pre> <p>This command will generate the admin.pubkey file by using the <code>init_admin.js</code> script, which is used to initialize the admin public key drived from the admin private key. </p> <p>Then, in your config.rs of the application, you can specify the admin public key as:</p> <pre><code>// In src/config.rs\nlazy_static::lazy_static! {\n    pub static ref ADMIN_PUBKEY: [u64; 4] = {\n        let bytes = include_bytes!(\"./admin.prikey\");\n        // Interpret the bytes as an array of u64\n        let u64s = unsafe { std::slice::from_raw_parts(bytes.as_ptr() as *const u64, 4) };\n        u64s.try_into().unwrap()\n    };\n}\n</code></pre> <p>When you need it, you can import the admin public key as:</p> <pre><code>use crate::config::ADMIN_PUBKEY;\n</code></pre> <p>When handling the user command including admin operatuons, you can use it like: <pre><code>  COMMAND =&gt; {\n    unsafe { require(*pkey == *ADMIN_PUBKEY) }; // check if the command is from the admin\n    ... // handle admin operations\n  }\n</code></pre></p> <p>You can find more concrete examples in the state implementation of automata game.</p>"},{"location":"zkwasm-mini-rollup/Rollup%20Server.html#rollup-settlement-monitor-tssettlets","title":"Rollup Settlement Monitor (ts/settle.ts)","text":"<p>The settlement module handles the crucial process of finalizing transactions on the blockchain. It verifies proofs and processes withdrawals through a series of carefully orchestrated steps.</p>"},{"location":"zkwasm-mini-rollup/Rollup%20Server.html#environment-setup","title":"Environment Setup","text":"<p>In order to run the settle.ts script, you need to firstly set enviroment variables in .env in the root directory of your application:</p> <pre><code>SETTLER_PRIVATE_ACCOUNT = YOUR_PRIVATE_ACCOUNT_PRIVATE_KEY\nSETTLEMENT_CONTRACT_ADDRESS = YOUR_SETTLEMENT_CONTRACT_ADDRESS\nIMAGE = YOUR_IMAGE_HASH\n</code></pre> <p>In settle.ts:</p> <pre><code>const signer = new ethers.Wallet(get_settle_private_account(), provider);\nconst constants = {\n    proxyAddress: get_contract_addr(),\n};\n</code></pre>"},{"location":"zkwasm-mini-rollup/Rollup%20Server.html#settlement-process","title":"Settlement Process","text":"<p>Here's the main settlement function that:</p> <ol> <li>Retrieves the current Merkle root</li> <li>Fetches associated proof data</li> <li>Verifies and submits the proof to the blockchain</li> <li>Checks if the transaction is successful and updates the record</li> </ol> <pre><code>async function trySettle() {\n    let merkleRoot = await getMerkle(); // get the merkle root from the proxy contract\n    let record = await modelBundle.findOne({ merkleRoot: merkleRoot});\n    if (record) {\n        // Fetch and verify proof\n        let data0 = await getTaskWithTimeout(taskId, 60000);\n\n        // get the proof data with verification instances\n        let shadowInstances = data0.shadow_instances; \n        let batchInstances = data0.batch_instances;\n        let proofArr = new U8ArrayUtil(data0.proof).toNumber();\n        let auxArr = new U8ArrayUtil(data0.aux).toNumber();\n        let verifyInstancesArr =  shadowInstances.length === 0\n        ? new U8ArrayUtil(batchInstances).toNumber()\n        : new U8ArrayUtil(shadowInstances).toNumber();\n        let instArr = new U8ArrayUtil(data0.instances).toNumber();\n        let txData = new Uint8Array(data0.input_context);\n\n        // Process proof data\n        const proxy = new ethers.Contract(constants.proxyAddress, abiData.abi, signer);\n        // Submit verification transaction\n        const tx = await proxy.verify(txData, proofArr, verifyInstancesArr, auxArr, [instArr]);\n        const receipt = await tx.wait();\n        .... // check the receipt\n        //update record\n        record.settleTxHash = tx.hash;\n        record.settleStatus = status;\n        await record.save();\n    }\n}\n</code></pre> <p>You can run the settle.ts script by:</p> <pre><code>node ts/settle.ts\n</code></pre> <p>And this will continueously check the proof and settle the transactions every 60 seconds:</p> <pre><code>// start monitoring and settle\nasync function main() {\n    while (true) {\n        try {\n            await trySettle();\n        } catch (error) {\n            console.error(\"Error during trySettle:\", error);\n        }\n     await new Promise(resolve =&gt; setTimeout(resolve, 60000));\n }\n}\n</code></pre>"},{"location":"zkwasm-mini-rollup/Rollup%20Server.html#proof-task-debugging-tsreproducets","title":"Proof Task Debugging (ts/reproduce.ts)","text":"<p>This module provides functionality to debug and reproduce zkWASM proof tasks by recreating their execution environment. It's particularly useful for investigating failed proof generations or verifying proof task behavior. </p> <p>Info</p> <p>To reproduce the proof task, you need to have the zkWasm Project Installed.</p>"},{"location":"zkwasm-mini-rollup/Rollup%20Server.html#task-retrieval","title":"Task Retrieval","text":"<p>In order to reproduce the proof task, you need to retrieve the task information from the service.</p> <pre><code>async function getTask(taskid: string) {\n    const queryParams: QueryParams = {\n        id: taskid,\n        tasktype: \"Prove\",\n        taskstatus: null,\n        user_address: null,\n        md5: null,\n        total: 1,\n    };\n    return (await ServiceHelper.loadTasks(queryParams)).data[0];\n}\n</code></pre> <p>This code can fetch detailed task information from the service, including:</p> <ul> <li>Public and private inputs</li> <li>Task status and metadata</li> </ul>"},{"location":"zkwasm-mini-rollup/Rollup%20Server.html#replay-the-task","title":"Replay the Task","text":"<p>When performing the proof task, you can use the following code to replay the task:</p> <pre><code>async function replay(taskId: string) {\n  const data0 = await getTask(taskId);\n  const public_inputs = data0.public_inputs;\n  const private_inputs = data0.private_inputs;\n  ... // handle the task\n}\n</code></pre>"},{"location":"zkwasm-mini-rollup/Rollup%20Server.html#environment-setup_1","title":"Environment Setup","text":"<p><pre><code>fs.writeFileSync('run-image.sh', `CLI=$HOME/zkWasm/target/release/zkwasm-cli\\n`);\nfs.appendFileSync('run-image.sh', `PARAMS=$HOME/zkWasm/params\\n`);\n</code></pre> The above code: </p> <ul> <li><code>CLI</code>: Defines the path to the zkWASM CLI executable</li> <li><code>PARAMS</code>: Specifies the parameter directory containing necessary proving parameters</li> </ul>"},{"location":"zkwasm-mini-rollup/Rollup%20Server.html#file-configuration","title":"File Configuration","text":"<pre><code>fs.appendFileSync('run-image.sh', `IMAGE=image.wasm\\n`);\nfs.appendFileSync('run-image.sh', `OUTPUT=output\\n`);\n</code></pre> <p>The above code:</p> <ul> <li><code>IMAGE</code>: Specifies the WASM binary to be executed</li> <li><code>OUTPUT</code>: Defines the directory for proof generation output</li> </ul>"},{"location":"zkwasm-mini-rollup/Rollup%20Server.html#cli-command-construction","title":"CLI Command Construction","text":"<pre><code>fs.appendFileSync('run-image.sh', `$CLI --params $PARAMS test dry-run --wasm $IMAGE \\\\\\n`, 'utf-8');\n</code></pre> <p>The above code constructs the base command with:</p> <ul> <li><code>test dry-run</code>: Executes in test mode for debugging</li> <li><code>--params</code>: Points to proving parameters</li> <li><code>--wasm</code>: Specifies the WASM image to execute</li> </ul>"},{"location":"zkwasm-mini-rollup/Rollup%20Server.html#input-parameters","title":"Input Parameters","text":"<p><pre><code>for (const p of public_inputs) {\n    fs.appendFileSync('run-image.sh', `--public ${p} \\\\\\n`, 'utf-8');\n}\nfor (const p of private_inputs) {\n    fs.appendFileSync('run-image.sh', `--private ${p} \\\\\\n`, 'utf-8');\n}\n</code></pre> The above code appends the public and private inputs to the CLI command.</p>"},{"location":"zkwasm-mini-rollup/Rollup%20Server.html#output-configuration","title":"Output Configuration","text":"<p><pre><code>fs.appendFileSync('run-image.sh', `--output $OUTPUT`, 'utf-8');\n</code></pre> The above code specifies the output directory for proof generation.</p> <p>The resulting script will look something like: <pre><code>CLI=$HOME/zkWasm/target/release/zkwasm-cli\nPARAMS=$HOME/zkWasm/params\nIMAGE=image.wasm\nOUTPUT=output\n$CLI --params $PARAMS test dry-run --wasm $IMAGE \\\n--public &lt;public_input_1&gt; \\\n--public &lt;public_input_2&gt; \\\n--private &lt;private_input_1&gt; \\\n--private &lt;private_input_2&gt; \\\n--output $OUTPUT\n</code></pre></p>"},{"location":"zkwasm-protocol/Custom%20Transaction.html","title":"Custom Transaction","text":""},{"location":"zkwasm-protocol/Custom%20Transaction.html#introduction","title":"Introduction","text":"<p>In this section, we will implement a custom transaction workflow for minting NFTs. This example demonstrates how to create a custom transaction that interacts with an NFT contract on the blockchain through the zkWasm protocol.</p> <p>Prerequisite</p> <p>Before implementing the NFT minting workflow, you need to:</p> <ol> <li>Deploy a proxy contract</li> <li>Deploy an NFT contract</li> <li>Add the NFT contract to the proxy contract using the <code>AddTransaction</code> method mentioned in the zkWasm Protocol Overview.</li> </ol>"},{"location":"zkwasm-protocol/Custom%20Transaction.html#nft-minting-flow-in-the-application","title":"NFT Minting flow in the application","text":"<p>As a custom transaction, the NFT minting function can be implemented in the <code>Transaction</code> struct. Here's an example implementation:</p> <pre><code>pub fn mint_nft(&amp;self, pid: &amp;[u64; 2]) -&gt; Result&lt;(), u32&gt; {\n    let mut player = Player::get_from_pid(pid);\n    match player.as_mut() {\n        None =&gt; Err(ERROR_PLAYER_NOT_EXIST),\n        Some(player) =&gt; {\n            // Check and increment nonce to prevent replay attacks\n            player.check_and_inc_nonce(self.nonce);\n\n            // Extract NFT data from transaction data\n            // data[0]: contains both address high bits and NFT level\n            // data[1], data[2]: rest of the address\n            let level = self.data[0] &amp; 0xffffffff;\n            let address_data = [self.data[0] &gt;&gt; 32, self.data[1], self.data[2]];\n\n            // Create mint information for settlement\n            let mint_info = MintInfo::new(&amp;address_data, level);\n            SettlementInfo::append_settlement(mint_info);\n\n            // Store updated player state\n            player.store();\n            Ok(())\n        }\n    }\n}\n\npub struct MintInfo {\n    pub feature: u32,     // 4 bytes: token type (0xFF for NFT)\n    pub address: [u8; 20], // 20 bytes: recipient address\n    pub level: u64,       // 8 bytes: NFT level\n}\n\nimpl MintInfo {\n    pub fn new(limbs: &amp;[u64; 3], level: u32) -&gt; Self {\n        let mut address = ((limbs[0]) as u32).to_le_bytes().to_vec();\n        address.extend_from_slice(&amp;limbs[1].to_le_bytes());\n        address.extend_from_slice(&amp;limbs[2].to_le_bytes());\n\n        MintInfo {\n            feature: 0xFF, // Special token index for NFT\n            address: address.try_into().unwrap(),\n            level: level as u64\n        }\n    }\n\n    pub fn flush(&amp;self, bytes: &amp;mut Vec&lt;u8&gt;) {\n        bytes.extend_from_slice(&amp;self.feature.to_le_bytes());\n        bytes.extend_from_slice(&amp;self.address);\n        bytes.extend_from_slice(&amp;self.level.to_be_bytes()); // solidity needs big endian\n    }\n}\n</code></pre> <p>Here's how a user can trigger the NFT minting function from the frontend:</p> <pre><code>async mintNFT(address: string, level: bigint) {\n    let nonce = await this.getNonce();\n    let addressBN = new BN(address, 16);\n    let a = addressBN.toArray(\"be\", 20); // 20 bytes = 160 bits and split into 4, 8, 8\n    /*\n    (32 bit level | 32 bit highbit of address)\n    (64 bit mid bit of address (be))\n    (64 bit tail bit of address (be))\n     */\n    let firstLimb = BigInt('0x' + bytesToHex(a.slice(0,4).reverse()));\n    let sndLimb = BigInt('0x' + bytesToHex(a.slice(4,12).reverse()));\n    let thirdLimb = BigInt('0x' + bytesToHex(a.slice(12, 20).reverse()));\n    try {\n        let processStamp = await this.rpc.sendTransaction(\n            new BigUint64Array([\n                createCommand(nonce, CMD_MINT_NFT, 0n),\n                (firstLimb &lt;&lt; 32n) + level,\n                sndLimb,\n                thirdLimb\n            ]), this.processingKey);\n        console.log(\"NFT mint processed at:\", processStamp);\n    } catch(e) {\n        if (e instanceof Error) {\n            console.log(e.message);\n        }\n        console.log(\"NFT minting error for address:\", address);\n    }\n}\n</code></pre> <p>Users can mint NFTs by calling the <code>mintNFT</code> function:</p> <pre><code>await this.mintNFT(\"YOUR_ADDRESS\", 5n);\n</code></pre>"},{"location":"zkwasm-protocol/Custom%20Transaction.html#nft-minting-flow-in-the-rollup-server","title":"NFT Minting flow in the rollup server","text":"<p>The minting process follows a similar pattern to other transactions in the rollup server:</p> <ol> <li>The server checks for the preemption threshold</li> <li>When reached, it calls the <code>finalize</code> function to collect settlement information</li> <li>The collected mint information is included in the proof generation process:</li> </ol> <pre><code>let task_id = await submitProofWithRetry(merkle_root, transactions_witness, txdata);\n</code></pre> <p>The <code>txdata</code> in this case will contain the NFT minting information that will be used during on-chain settlement.</p>"},{"location":"zkwasm-protocol/Custom%20Transaction.html#settle-on-the-blockchain","title":"Settle on the blockchain","text":"<p>The settlement monitor needs to handle both withdraw and NFT mint transactions. Here's the implementation:</p> <pre><code>// Decode both withdraw and NFT mint transactions from txdata\nexport function decodeTxData(txdata: Uint8Array) {\n    let withdraws = [];\n    let nftMints = [];\n\n    if (txdata.length &gt; 1) {\n        for (let i = 0; i &lt; txdata.length; i += 32) {\n            let extra = txdata.slice(i, i+4);\n            let address = txdata.slice(i+4, i+24);\n            let valueData = txdata.slice(i+24, i+32);\n\n            if (extra[1] === 0xFF) { // NFT mint\n                nftMints.push({\n                    op: extra[0],\n                    index: extra[1],\n                    address: ethers.getAddress(bytesToHex(Array.from(address))),\n                    level: Number(bytesToDecimal(Array.from(valueData))),\n                });\n            } else { // Withdraw\n                withdraws.push({\n                    op: extra[0],\n                    index: extra[1],\n                    address: ethers.getAddress(bytesToHex(Array.from(address))),\n                    amount: ethers.parseEther(bytesToDecimal(Array.from(valueData))),\n                });\n            }\n        }\n    }\n    return { withdraws, nftMints };\n}\n\n// Get NFT mint events from transaction receipt\nasync function getNFTMintEventParameters(\n    proxy: ethers.Contract,\n    receipt: ethers.ContractTransactionReceipt\n): Promise&lt;any[]&gt; {\n    let r: any[] = [];\n    try {\n        const eventSignature = \"event NFTMinted(address nftContract, address recipient, uint256 level)\";\n        const iface = new ethers.Interface([eventSignature]);\n\n        const logs = receipt.logs;\n        logs.forEach(log =&gt; {\n            try {\n                const decoded = iface.parseLog(log);\n                if (decoded) {\n                    const nftContract = decoded.args.nftContract;\n                    const recipient = decoded.args.recipient;\n                    const level = decoded.args.level;\n                    r.push({\n                        nftContract,\n                        address: recipient,\n                        level: level,\n                    });\n                }\n            } catch (error) {\n                // Handle logs that don't match the event signature\n            }\n        });\n    } catch (error) {\n        console.error('Error retrieving NFT mint event parameters:', error);\n    }\n    return r;\n}\n\nasync function trySettle() {\n    let merkleRoot = await getMerkle();\n    try {\n        let record = await modelBundle.findOne({ merkleRoot: merkleRoot });\n        if (record) {\n            let taskId = record.taskId;\n            let data0 = await getTaskWithTimeout(taskId, 60000);\n\n            // Check failed or just timeout\n            if (data0.proof.length == 0) {\n                let data1 = await getTask(taskId, null);\n                if (data1.status === \"DryRunFailed\" || data1.status === \"Unprovable\") {\n                    console.log(\"Crash(Need manual review): task failed with state:\", taskId, data1.status, data1.input_context);\n                    while(1);\n                    return -1;\n                } else {\n                    console.log(`Task: ${taskId}, ${data1.status}, retry settle later.`);\n                    return -1;\n                }\n            }\n\n            // Prepare proof data\n            let shadowInstances = data0.shadow_instances;\n            let batchInstances = data0.batch_instances;\n            let proofArr = new U8ArrayUtil(data0.proof).toNumber();\n            let auxArr = new U8ArrayUtil(data0.aux).toNumber();\n            let verifyInstancesArr = shadowInstances.length === 0\n                ? new U8ArrayUtil(batchInstances).toNumber()\n                : new U8ArrayUtil(shadowInstances).toNumber();\n            let instArr = new U8ArrayUtil(data0.instances).toNumber();\n            let txData = new Uint8Array(data0.input_context);\n\n            // Verify proof\n            const proxy = new ethers.Contract(constants.proxyAddress, abiData.abi, signer);\n            const tx = await proxy.verify(txData, proofArr, verifyInstancesArr, auxArr, [instArr]);\n            const receipt = await tx.wait();\n\n            // Decode and verify transactions\n            const { withdraws, nftMints } = decodeTxData(txData);\n            const withdrawEvents = await getWithdrawEventParameters(proxy, receipt);\n            const nftMintEvents = await getNFTMintEventParameters(proxy, receipt);\n\n            let status = 'Done';\n\n            // Verify withdraws\n            if (withdraws.length &gt; 0) {\n                if (withdraws.length !== withdrawEvents.length) {\n                    status = 'Fail';\n                    console.error(\"Withdraw arrays have different lengths\", withdraws, withdrawEvents);\n                } else {\n                    for (let i = 0; i &lt; withdraws.length; i++) {\n                        const offchain = withdraws[i];\n                        const onchain = withdrawEvents[i];\n                        if (offchain.address !== onchain.address || offchain.amount !== onchain.amount) {\n                            console.log(\"Crash(Need manual review):\");\n                            console.error(`Withdraw mismatch: ${offchain.address}:${offchain.amount} ${onchain.address}:${onchain.amount}`);\n                            while(1);\n                            status = 'Fail';\n                            break;\n                        }\n                    }\n                }\n            }\n\n            // Verify NFT mints\n            if (nftMints.length &gt; 0) {\n                if (nftMints.length !== nftMintEvents.length) {\n                    status = 'Fail';\n                    console.error(\"NFT mint arrays have different lengths\", nftMints, nftMintEvents);\n                } else {\n                    for (let i = 0; i &lt; nftMints.length; i++) {\n                        const offchain = nftMints[i];\n                        const onchain = nftMintEvents[i];\n                        if (offchain.address !== onchain.address || offchain.level !== onchain.level) {\n                            console.log(\"Crash(Need manual review):\");\n                            console.error(`NFT mint mismatch: ${offchain.address}:${offchain.level} ${onchain.address}:${onchain.level}`);\n                            while(1);\n                            status = 'Fail';\n                            break;\n                        }\n                    }\n                }\n            }\n\n            // Update record\n            record.settleTxHash = tx.hash;\n            record.settleStatus = status;\n            record.transactions = {\n                withdraws: withdraws,\n                nftMints: nftMints\n            };\n            await record.save();\n            console.log(\"Receipt verified\");\n        } else {\n            console.log(`proof bundle ${merkleRoot} not found`);\n        }\n    } catch(e) {\n        console.log(\"Exception happen in trySettle()\");\n        console.log(e);\n    }\n}\n</code></pre> <p>This implementation includes the following key changes:</p> <ol> <li> <p><code>decodeTxData</code> function:</p> <ul> <li>Handles both withdraw and NFT mint transactions</li> <li>Uses token index (0xFF) to differentiate between transaction types</li> <li>Returns separate arrays for withdraws and NFT mints</li> </ul> </li> <li> <p>Added <code>getNFTMintEventParameters</code>:</p> <ul> <li>Similar to <code>getWithdrawEventParameters</code></li> <li>Decodes NFT mint events from transaction logs</li> </ul> </li> <li> <p>Enhanced <code>trySettle</code>:</p> <ul> <li>Verifies both types of transactions</li> <li>Maintains separate verification logic for each type</li> <li>Updates record with both withdraw and NFT mint information</li> </ul> </li> <li> <p>Error handling:</p> <ul> <li>Checks for mismatches in both transaction types</li> <li>Triggers manual review if any verification fails</li> <li>Maintains separate status tracking for different transaction types</li> </ul> </li> </ol> <p>This implementation ensures that both withdraw and NFT mint transactions are properly verified and recorded in the settlement process.</p>"},{"location":"zkwasm-protocol/Custom%20Transaction.html#proxy-contract-modification","title":"Proxy Contract Modification","text":"<p>In proxy contract, you can implement the NFT minting functionality by adding the following code:</p> <pre><code>// In your proxy contract\nfunction _update_state(uint256[] memory deltas) private {\n    uint256 cursor = 0;\n    while (cursor &lt; deltas.length) {\n        uint256 delta_code = deltas[cursor];\n        if (delta_code == _WITHDRAW) {\n            require(\n                deltas.length &gt;= cursor + 4,\n                \"Withdraw: Insufficient arg number\"\n            );\n            _withdraw(\n                uint128(deltas[cursor + 1]),\n                uint128(deltas[cursor + 2]),\n                deltas[cursor + 3]\n            );\n            cursor = cursor + 4;\n        } else if (delta_code == _MINT_NFT) {\n            require(\n                deltas.length &gt;= cursor + 4,\n                \"MintNFT: Insufficient arg number\"\n            );\n            _mintNFT(\n                uint128(deltas[cursor + 1]), // token index (should be 0xFF)\n                uint128(deltas[cursor + 2]), // level\n                deltas[cursor + 3]          // recipient address\n            );\n            cursor = cursor + 4;\n        } else {\n            revert(\"SideEffect: UnknownSideEffectCode\");\n        }\n    }\n}\n\nfunction _mintNFT(\n    uint128 tidx,\n    uint128 level,\n    uint256 l1recipient\n) private {\n    require(tidx == 0xFF, \"Invalid token index for NFT mint\");\n    address recipient = address(uint160(l1recipient));\n\n    // Sanity checks\n    require(recipient != address(0), \"Mint to the zero address\");\n    require(level &gt; 0, \"Invalid NFT level\");\n\n    // Get NFT contract address from registry\n    address nftContract = nftContracts[tidx];\n    require(nftContract != address(0), \"NFT contract not registered\");\n\n    // Generate URI based on level (implementation depends on your needs)\n    string memory uri = generateNFTURI(level);\n\n    // Call mint function on NFT contract\n    INFTContract(nftContract).mint(recipient, level, uri);\n    emit NFTMinted(nftContract, recipient, level);\n}\n\n// Event for NFT minting\nevent NFTMinted(address indexed nftContract, address indexed recipient, uint256 level);\n\n// Interface for NFT contract\ninterface INFTContract {\n    function mint(address to, uint256 level, string memory uri) external;\n}\n</code></pre> <p>The key components of the proxy implementation are:</p> <ol> <li> <p><code>_update_state</code> modification:</p> <ul> <li>Added handling for <code>_MINT_NFT</code> operation code</li> <li>Extracts token index, level, and recipient address from deltas</li> <li>Calls <code>_mintNFT</code> function with the extracted parameters</li> </ul> </li> <li> <p><code>_mintNFT</code> function:</p> <ul> <li>Verifies token index is 0xFF (special index for NFT)</li> <li>Performs sanity checks on recipient address and level</li> <li>Retrieves NFT contract address from registry</li> <li>Generates URI based on level</li> <li>Calls mint function on the NFT contract</li> </ul> </li> </ol> <p>This implementation allows the proxy to:</p> <ul> <li>Handle both withdraw and NFT mint operations</li> <li>Generate appropriate URIs based on NFT levels</li> <li>Emit events for tracking minting operations</li> </ul> <p>The proxy acts as a coordinator between the rollup and the NFT contract, ensuring that minting operations are executed only after successful proof verification.</p>"},{"location":"zkwasm-protocol/Deposit.html","title":"Deposit Workflow","text":""},{"location":"zkwasm-protocol/Deposit.html#introduction","title":"Introduction","text":"<p>In this section, we will use what we have learned from zkWasm Protocol Overview to implement a deposit workflow. </p>"},{"location":"zkwasm-protocol/Deposit.html#the-topup-function","title":"The Topup Function","text":"<p>In the proxy contract, we have a function <code>topup</code> which can be called by any user to deposit specific token into the zkWasm Rollup Application. </p> <pre><code>function topup (\n    uint128 tidx,\n    uint64 pid_1,\n    uint64 pid_2,\n    uint128 amount  //in wei\n) nonReentrant public {\n    uint256 tokenid = get_token_uid(tidx);\n    require (_is_local(tokenid), \"token is not a local erc token\");\n    address token = address(uint160(tokenid));\n    IERC20 underlying_token = IERC20(token);\n\n    uint256 balance = underlying_token.balanceOf(msg.sender);\n    require(balance &gt;= amount, \"Insufficient Balance\");\n\n    uint256 allowance = underlying_token.allowance(msg.sender, address(this));\n    require(allowance &gt;= amount, \"Insufficient Allowance\");\n\n    //USDT does not follow ERC20 interface so have to use the following safer method\n    TransferHelper.safeTransferFrom(address(underlying_token), msg.sender, address(this), amount);\n\n    //TBD: Charge fees to developer\n    emit TopUp(_l1_address(token), msg.sender, pid_1, pid_2, amount);\n}\n</code></pre> <p>The <code>topup</code> function accepts four parameters that control the deposit process:</p> <ul> <li>The <code>tidx</code> parameter (uint128) represents the token index in the contract's token registry. This index is used to retrieve the actual token contract address through the <code>get_token_uid</code> function.</li> <li>The <code>pid_1</code> and <code>pid_2</code> parameters (both uint64) together form a unique player identifier within the zkWasm system. This two-part identifier corresponds to the <code>player_id: [u64; 2]</code> structure used in the <code>Player</code> struct in the zkWasm mini rollup ABI. Therefore, we can use the <code>pid_1</code> and <code>pid_2</code> to identify which player is depositing the token.</li> <li>The <code>amount</code> parameter (uint128) specifies the deposit amount in wei, representing the smallest unit of the token being deposited, this means the amount has to be multiplied by 10^18 to represent the actual amount of the token.</li> </ul> <p>When a user calls the <code>topup</code> function, the following steps will be performed:</p> <ol> <li>The <code>topup</code> function will first check if the token is a local token (which means the token is supported by the blockchain) by calling the <code>_is_local</code> function. If the token is not a local token, the function will revert with an error message.</li> <li>The function will then check if the user has enough balance and allowance to deposit the token. If not, the function will revert with an error message.</li> <li>The function will then transfer the token from the user's account to the proxy contract.</li> <li>The function will then emit a <code>TopUp</code> event to notify the zkWasm Rollup Application that the user has deposited the token.</li> </ol> <p>You can add more features to the <code>topup</code> function, such as charging fees to the developer, or checking if the user is on the whitelist.</p> <p>Imagine a user has deposited a token into the zkWasm Rollup Application and the <code>TopUp</code> event has been emitted. What will happen next? </p> <p>Actually... nothing will happen next. The <code>TopUp</code> event is just a notification event, it does not trigger any further actions. So how does the zkWasm Rollup Application know that the user has deposited the token? We need to implement a mechanism to listen to the <code>TopUp</code> event and trigger the corresponding actions to process the deposit in the zkWasm Rollup Application. A good way to do this is to use a deposit monitor which operates by the server's admin.</p>"},{"location":"zkwasm-protocol/Deposit.html#deposit-monitor","title":"Deposit Monitor","text":"<p>In this section, we will implement a typescript node.js service that can listen to the <code>TopUp</code> event and trigger the corresponding actions to process the deposit in the zkWasm Rollup Application. The original code is in the <code>deposit.ts</code> file in a game called automata.</p> <p>Let's start by implementing the service that can: 1. retrieve all past <code>TopUp</code> events from the proxy contract and process each event.  2. listen to new <code>TopUp</code> events from the proxy contract and process each event.</p> <p>The service can be concluded as the following code: <pre><code>async function main() {\n    const dbName = `${process.env.SETTLEMENT_CONTRACT_ADDRESS}_deposit`; // Dynamically set DB name using contract address\n    // Connect to MongoDB (without deprecated options)\n    await mongoose.connect(process.env.MONGO_URI, {\n        dbName,\n    }).then(() =&gt; console.log('MongoDB connected'));\n    // Get all TopUp events from the contract\n    await getTopUpEvents();\n    // Listen for new TopUp events\n    proxyContract.on('TopUp', async (l1token, address, pid_1, pid_2, amount, event) =&gt; {\n        console.log(event);\n        //const eventLog = event as EventLog;  // Explicitly cast to EventLog\n        //console.log(eventLog);\n        console.log(`New TopUp event detected: ${event.log.transactionHash}`);\n        // Process the new TopUp event\n        await processTopUpEvent(event.log);\n    });\n}\n</code></pre></p> <p>In order to make sure the events will not be processed multiple times, we need to store the events transaction information in the database. Here we use MongoDB to do this.</p> <p><pre><code>const txSchema = new mongoose.Schema({\n    txHash: { type: String, required: true, unique: true }, // Ensure txHash is unique\n    state: { type: String, enum: ['pending', 'in-progress', 'completed', 'failed'], default: 'pending' },\n    timestamp: { type: Date, default: Date.now },\n    l1token: { type: String, required: true },\n    address: { type: String, required: true },\n    pid_1: { type: BigInt, required: true },\n    pid_2: { type: BigInt, required: true },\n    amount: { type: BigInt, required: true },\n});\nconst TxHash = mongoose.model('TxHash', txSchema);\n</code></pre> The above code defines a schema for the <code>TxHash</code> collection in the database. Each <code>TxHash</code> document will have fields that correspond to the parameters of the <code>TopUp</code> event. Notably, the state field is used to indicate the status of the event processing which can be used to prevent the event from being processed multiple times.</p> <p>When we start the service, after connecting to the database, we will first retrieve all past <code>TopUp</code> events from the proxy contract and process each event. This is specifically useful for the server's admin to check if there are any deposits that need to be processed when initializing the monitor:</p> <pre><code>// Function to retrieve all past TopUp events\nasync function getTopUpEvents() {\n    try {\n        // You can specify a block range, or use `fromBlock: 0` to query all events\n        const filter = proxyContract.filters.TopUp();\n        const events = await proxyContract.queryFilter(filter, 0, 'latest');\n        console.log(`Found ${events.length} TopUp events.`);\n        for (const event of events) {\n            const eventLog = event;\n            // Process each past event\n            await processTopUpEvent(eventLog);\n        }\n    }\n    catch (error) {\n        console.error('Error retrieving TopUp events:', error);\n    }\n}\n</code></pre> <p>Then the service will listen to new <code>TopUp</code> events from the proxy contract and process each event: <pre><code>proxyContract.on('TopUp', async (l1token, address, pid_1, pid_2, amount, event) =&gt; {\n    console.log(event);\n    //const eventLog = event as EventLog;  // Explicitly cast to EventLog\n    //console.log(eventLog);\n    console.log(`New TopUp event detected: ${event.log.transactionHash}`);\n    // Process the new TopUp event\n    await processTopUpEvent(event.log);\n});\n</code></pre></p> <p>Once there is a new <code>TopUp</code> event, the service will process the event by calling the <code>processTopUpEvent</code> function. </p> <p>Let's take a look at the <code>processTopUpEvent</code> function:</p> <pre><code>async function processTopUpEvent(event) {\n    const eventLog = event;\n    const [l1token, address, pid_1, pid_2, amount] = eventLog.args;\n    if (l1token !== (await proxyContract._tokens(0))) {\n        console.log('Skip not the right token: ', l1token);\n        return;\n    }\n    console.log(`TopUp event received: pid_1=${pid_1.toString()}, pid_2=${pid_2.toString()}, amount=${amount.toString()} wei`);\n    // Check if this transaction is already in the database and in 'pending' or 'in-progress' state\n    let tx = await findTxByHash(event.transactionHash);\n    ...\n}\n</code></pre> <p>First, the function will check if the token is the right token (the token that can be deposited into the zkWasm Rollup Application) by comparing the <code>l1token</code> (which is the uid of the token) with the token uid stored in the proxy contract. If the token is not the right token, the function will skip the event. </p> <p>Tip</p> <p>You can implement your own logic to check if the token is the right token by checking the token's uid, for example, if you want to make all the tokens that have been registered in the proxy contract can be deposited into the zkWasm Rollup Application, you can skip the check (because the token has been checked in the <code>topup</code> function in the proxy contract when user deposit the token) or check if the token is supported by the proxy contract by calling the <code>allTokens</code> function and check if the <code>l1token</code> is in the <code>allTokens</code> array.</p> <p>Then the function will check if the transaction is already in the database by calling the <code>findTxByHash</code> function:</p> <pre><code>let tx = await findTxByHash(event.transactionHash);\n</code></pre> <p>If the transaction is not in the database, the function will create a new transaction record which has the initial state as <code>pending</code> in the database:</p> <pre><code>        if (!tx) {\n            console.log(`Transaction hash not found: ${event.transactionHash}`);\n            // Save tx hash and initial state as pending, along with other details\n            tx = new TxHash({\n                txHash: event.transactionHash,\n                state: 'pending', // Initially set to pending\n                l1token,\n                address,\n                pid_1,\n                pid_2,\n                amount,\n            });\n            await tx.save();\n        }\n</code></pre> <p>If the transaction is already in the database or just created through the above code, the function will check if the transaction is in the <code>pending</code> status, if so, it will proceed to process the deposit in the zkWasm Rollup Application:</p> <pre><code>if (tx &amp;&amp; tx.state === 'pending') {\n    try {\n        // Set transaction state to \"in-progress\"\n        await updateTxState(event.transactionHash, 'in-progress');\n        // Convert amount from wei to ether\n        let amountInEther = amount / BigInt(10 ** 18);\n        console.log(\"Deposited amount (in ether): \", amountInEther);\n        if (amountInEther &lt; 1n) {\n            console.error(`--------------Skip: Amount must be at least 1 Titan (in ether instead of wei) ${event.transactionHash}\\n`);\n        }\n        else {\n            // Proceed with the deposit\n            await admin.deposit(pid_1, pid_2, amountInEther);\n            console.log(`------------------Deposit successful! ${event.transactionHash}\\n`);\n        }\n        // After successful deposit, set state to 'completed'\n        await updateTxState(event.transactionHash, 'completed');\n    }\n    catch (error) {\n        console.error('Error during deposit:', error);\n        // In case of failure, mark as 'failed'\n        // await updateTxState(event.transactionHash, 'failed');\n    }\n}\n</code></pre> <p>The above code will set the transaction state to <code>in-progress</code>, then convert the amount from wei to ether, and then call the <code>deposit</code> function in the zkWasm Rollup Application to process the deposit. After the deposit is successful, the function will set the transaction state to <code>completed</code>. However, if the deposit fails, the status of the transaction will not be updated to <code>completed</code> and will remain as <code>in-progress</code>.</p> <p>Admin Setup</p> <p>The <code>deposit</code> function is a function in the zkWasm Rollup Application, which is only callable by the admin. You will need to setup the admin key as <code>SERVER_ADMIN_KEY</code> in the <code>.env</code> file first before you can call the <code>deposit</code> function. Also, as a kind of \"player\", you will need to install the admin into the zkWasm Rollup Application by calling the <code>installPlayer</code> function: <pre><code>const rpc = new ZKWasmAppRpc(\"https://rpc.zkplay.app\");\nlet admin = new Player(process.env.SERVER_ADMIN_KEY, rpc);\nconsole.log(\"install admin ...\\n\");\nawait admin.installPlayer();\n</code></pre></p> <p>If the transaction is in the <code>in-progress</code> state, the function will skip the deposit process as this indicates that something went wrong during the deposit process and requires manual intervention.</p> <p>If the transaction is in the <code>completed</code> state, the function will skip the deposit process as this indicates that the deposit has already been processed.</p>"},{"location":"zkwasm-protocol/Deposit.html#deposit-action","title":"Deposit Action","text":"<p>Let's take a look at how admin deposits the token into the zkWasm Rollup Application, in <code>process</code> function in state.rs of the zkWasm Rollup Application (automata):</p> <p><pre><code>DEPOSIT =&gt; {\n    unsafe { require(*pkey == *ADMIN_PUBKEY) };\n    self.deposit(&amp;AutomataPlayer::pkey_to_pid(pkey))\n        .map_or_else(|e| e, |_| 0)\n}\n</code></pre> When it receives a deposit request (<code>admin.deposit(pid_1, pid_2, amountInEther)</code> called in the deposit monitor), it will check if the request is coming from the admin by checking if the public key is the admin's public key (You will get the admin's public key generated from your private key when you build the zkWasm Rollup Application using <code>make build</code>). If it is, it will call the <code>deposit</code> function.</p> <p>Let's take a look at the <code>deposit</code> function in the zkWasm Rollup Application:</p> <pre><code>pub fn deposit(&amp;self, pid: &amp;[u64; 2]) -&gt; Result&lt;(), u32&gt; {\n    //zkwasm_rust_sdk::dbg!(\"deposit\\n\");\n    let mut admin = AutomataPlayer::get_from_pid(pid).unwrap();\n    admin.check_and_inc_nonce(self.nonce);\n    let mut player = AutomataPlayer::get_from_pid(&amp;[self.data[0], self.data[1]]);\n    match player.as_mut() {\n        None =&gt; {\n            let mut player = AutomataPlayer::new_from_pid([self.data[0], self.data[1]]);\n            player.data.cost_balance(-(self.data[2] as i64))?;\n            player.store();\n        }\n        Some(player) =&gt; {\n            player.data.cost_balance(-(self.data[2] as i64))?;\n            player.store();\n        }\n    };\n    admin.store();\n    Ok(()) // no error occurred\n}\n</code></pre> <p>Remember how we call the <code>deposit</code> function in the deposit monitor, we use the <code>pid_1</code> and <code>pid_2</code> to identify the player, and the <code>amount</code> to specify the amount of the token to be deposited:</p> <pre><code>await admin.deposit(pid_1, pid_2, amountInEther);\n</code></pre> <p>So the <code>deposit</code> function will first get the player from the pid, then check if the player exists, if not, it will create a new player with the pid, then it will add the amount to the player's balance by <code>player.data.cost_balance(-(self.data[2] as i64))?;</code>.</p> <p>Balance Update</p> <p>The <code>cost_balance</code> function in the zkWasm Rollup Application handles both deposit and withdrawal operations through a clever use of positive and negative values. Here's how it works:</p> <p>When processing a deposit with <code>cost_balance(-x)</code>, the function:</p> <ol> <li>Checks if <code>treasure &gt;= -x</code></li> <li>Executes <code>treasure -= (-x)</code>, which is equivalent to <code>treasure += x</code></li> </ol> <p>This is why in the deposit function we see <code>cost_balance(-(self.data[2] as i64))</code>:</p> <ul> <li>First converts <code>self.data[2]</code> to a 64-bit integer</li> <li>Takes its negative value to make it a deposit operation</li> <li>Uses <code>cost_balance</code> to update the balance</li> </ul> <p>This is a common design pattern where a single function handles both increasing and decreasing balances, using the sign of the value to determine the operation type. When the input is negative, it becomes a deposit (increasing balance), and when positive, it becomes a withdrawal (decreasing balance).</p> <p>Here's the implementation: <pre><code>pub fn cost_balance(&amp;mut self, b: i64) -&gt; Result&lt;(), u32&gt; {\n    if let Some(treasure) = self.local.0.last_mut() {\n        if *treasure &gt;= b {\n            *treasure -= b;\n            Ok(())\n        } else {\n            Err(ERROR_NOT_ENOUGH_BALANCE)\n        }\n    } else {\n        unreachable!();\n    }\n}\n</code></pre></p> <p>The balance (or \"treasure\") is stored in the last element of the player's <code>local</code> array, which is part of the player's data structure containing balance and other information.</p>"},{"location":"zkwasm-protocol/Withdraw.html","title":"Withdraw Workflow","text":""},{"location":"zkwasm-protocol/Withdraw.html#introduction","title":"Introduction","text":"<p>In this section, we will use what we have learned from zkWasm Protocol Overview and Rollup Settlement Monitor to implement a withdraw workflow. </p> <p>Prerequisite</p> <p>In order to implement the withdraw workflow, you may need to deploy a proxy contract and a withdraw contract and add the withdraw contract to the proxy contract through <code>AddTransaction</code> method mentioned in the zkWasm Protocol Overview.</p>"},{"location":"zkwasm-protocol/Withdraw.html#withdraw-flow-in-the-application","title":"Withdraw flow in the application","text":"<p>As a kind of transaction, the withdraw function can be implemented in the <code>Transaction</code> struct which we have discussed a little bit in the Quick Tutorial. Take automata as an example, the withdraw function is implemented in the <code>Transaction</code> struct as follows:</p> <pre><code>pub fn withdraw(&amp;self, pid: &amp;[u64; 2]) -&gt; Result&lt;(), u32&gt; {\n    let mut player = AutomataPlayer::get_from_pid(pid);\n    match player.as_mut() {\n        None =&gt; Err(ERROR_PLAYER_NOT_EXIST),\n        Some(player) =&gt; {\n            player.check_and_inc_nonce(self.nonce);\n            let amount = self.data[0] &amp; 0xffffffff;\n            player.data.cost_balance(amount as i64)?;\n            let withdrawinfo =\n                WithdrawInfo::new(&amp;[self.data[0], self.data[1], self.data[2]], 0);\n            SettlementInfo::append_settlement(withdrawinfo);\n            player.store();\n            Ok(())\n        }\n    }\n}\n</code></pre> <p>The above code first checks if the player exists, then checks if the nonce is valid, then deducts the balance of the player, and finally appends the withdraw information to the settlement information. And here's how a player can trigger the withdraw function, in the frontend: </p> <pre><code>async withdrawRewards(address: string, amount: bigint) {\n    let nonce = await this.getNonce();\n    let addressBN = new BN(address, 16);\n    let a = addressBN.toArray(\"be\", 20); // 20 bytes = 160 bits and split into 4, 8, 8\n    /*\n    (32 bit amount | 32 bit highbit of address)\n    (64 bit mid bit of address (be))\n    (64 bit tail bit of address (be))\n     */\n    let firstLimb = BigInt('0x' + bytesToHex(a.slice(0,4).reverse()));\n    let sndLimb = BigInt('0x' + bytesToHex(a.slice(4,12).reverse()));\n    let thirdLimb = BigInt('0x' + bytesToHex(a.slice(12, 20).reverse()));\n    try {\n      let processStamp = await this.rpc.sendTransaction(\n        new BigUint64Array([\n          createCommand(nonce, CMD_WITHDRAW, 0n),\n          (firstLimb &lt;&lt; 32n) + amount,\n          sndLimb,\n          thirdLimb\n        ]), this.processingKey);\n      console.log(\"withdraw rewards processed at:\", processStamp);\n    } catch(e) {\n      if (e instanceof Error) {\n        console.log(e.message);\n      }\n      console.log(\"collect reward error at address:\", address);\n    }\n}\n</code></pre> <p>The function first converts the hexadecimal address string into a byte array, then the 20-byte address is then split into three parts. For example, if we have an address <code>0x742d35Cc6634C0532925a3b844Bc454e4438f44e</code>, it is split as follows:</p> <ul> <li>firstLimb:  <code>[74 2d 35 cc]</code>           (4 bytes, 32 bits, used to combine with the withdrawal amount) </li> <li>sndLimb:    <code>[66 34 c0 53 29 25 a3 b8]</code> (8 bytes, 64 bits)</li> <li>thirdLimb:  <code>[44 bc 45 4e 44 38 f4 4e]</code> (8 bytes, 64 bits)</li> </ul> <p>The withdrawal amount needs to be combined with part of the address. This is done by: <pre><code>(firstLimb &lt;&lt; 32n) + amount\n</code></pre></p> <p>This operation:</p> <ol> <li>Shifts the first 4 bytes of the address left by 32 bits</li> <li>Adds the withdrawal amount in the lower 32 bits</li> </ol> <p>Finally we send the transaction to the rollup server by creating a command with the <code>CMD_WITHDRAW</code> command.</p> <p>The users can withdraw their rewards by calling the <code>withdrawRewards</code> function:</p> <pre><code>await this.withdrawRewards(address, amount);\n</code></pre> <p>And this will be processed in the <code>process</code> function of the <code>Transaction</code> struct in <code>state.rs</code> and the withdraw function will be called:</p> <pre><code>WITHDRAW =&gt; self\n    .withdraw(&amp;AutomataPlayer::pkey_to_pid(pkey))\n    .map_or_else(|e| e, |_| 0),\n</code></pre>"},{"location":"zkwasm-protocol/Withdraw.html#withdraw-flow-in-the-rollup-server","title":"Withdraw flow in the rollup server","text":"<p>You may notice that the withdraw function just appends the withdraw information to the settlement information and then returns. Remember that the withdraw transactions will be submitted with <code>merkle_root</code> and <code>transactions_witness</code> to the zkWasm Hub or your own zkWasm Prover to generate proofs when the rollup server is ready to settle, you may have a look at Transaction Installation (Rollup). This takes several steps:</p> <ol> <li> <p>First, the server will check if the application has reached the preemption threshold:</p> <pre><code>if (application.preempt()){\n    ...\n}\n</code></pre> </li> <li> <p>If the application has reached the preemption threshold, the server will call the <code>finalize</code> function to get the settlement information (withdraw information):</p> <pre><code>let txdata = application.finalize();\n</code></pre> <p>Let's take a look at the <code>finalize</code> function in zkWasm Mini Rollup's ABI:</p> <pre><code>#[wasm_bindgen]\npub fn finalize() -&gt; Vec&lt;u8&gt; {\n    unsafe {\n        let bytes = $S::flush_settlement();\n        $S::store();\n        bytes // This is the txdata\n    }\n}\n</code></pre> <p>The <code>finalize</code> function will call the implemented <code>flush_settlement</code> function in your application to get the settlement information which the application has appended in the withdraw function and return it to the server.</p> <p>Note</p> <p>For the details of the <code>ABI</code> which represents the workflow of rollup, you may have a look at zkWasm Rust SDK</p> </li> <li> <p>Finally, if your server are not in the tryrun mode (which means you are in deploy mode), the txdata will be sent to the zkWasm Hub or your own zkWasm Prover with other data to generate proofs:</p> <pre><code>let task_id = await submitProofWithRetry(merkle_root, transactions_witness, txdata);\n</code></pre> <p>Then a bundleRecord will be created in the zkWasm Mini Rollup's database:</p> <pre><code>const bundleRecord = new modelBundle({\n    merkleRoot: merkleRootToBeHexString(merkle_root),\n    taskId: task_id,\n});\nawait bundleRecord.save();\n</code></pre> <p>This will be used later when we verify the proofs and settle on the blockchain.</p> <p>Merkle Root</p> <p>The submitted <code>merkle_root</code> is the old root (which indicates the root before the current batch of transactions).</p> </li> </ol>"},{"location":"zkwasm-protocol/Withdraw.html#settle-on-the-blockchain","title":"Settle on the blockchain","text":"<p>Let's assume the proof has been generated successfully by zkWasm Hub or your own zkWasm Prover, and you have already deployed your proxy contract. The next step is to settle on the blockchain. In order to do this, we need a settlement monitor to periodically verify the proofs. You may first take a look on Rollup Settlement Monitor to learn how to implement a settlement monitor. In its core function <code>trySettle</code>, you can find the following code:</p> <pre><code>let merkleRoot = await getMerkle();\n</code></pre> <p>The function first gets the merkle root from the proxy contract, which is the old root as we have mentioned in the note of the previous section. Then it will get the bundleRecord from the database by the old root: </p> <pre><code>let record = await modelBundle.findOne({ merkleRoot: merkleRoot });\n</code></pre> <p>It then gets all the data needed for the proof verification from zkWasm Hub by the taskId from the bundleRecord:</p> <pre><code>let taskId = record.taskId;\nlet data0 = await getTaskWithTimeout(taskId, 60000);\n</code></pre> <p>After getting all the data, the monitor will verify the proof and settle on the blockchain if the proof is valid:</p> <pre><code>let txData = new Uint8Array(data0.input_context);\nlet proofArr = new U8ArrayUtil(data0.proof).toNumber();\n\nlet shadowInstances = data0.shadow_instances;\nlet batchInstances = data0.batch_instances;\nlet verifyInstancesArr = shadowInstances.length === 0\n    ? new U8ArrayUtil(batchInstances).toNumber()\n    : new U8ArrayUtil(shadowInstances).toNumber();\nlet auxArr = new U8ArrayUtil(data0.aux).toNumber();\nlet instArr = new U8ArrayUtil(data0.instances).toNumber();\n\nconst tx = await proxy.verify(txData, proofArr, verifyInstancesArr, auxArr, [instArr]);\nconst receipt = await tx.wait();\n</code></pre> <p>Then we can update the database with withdraw information and transaction hash after checking the withdraw parameters from blockchain events with the txData we got from the proof generation task of zkWasm Hub:</p> <pre><code>const r = decodeWithdraw(txData);\nconst s = await getWithdrawEventParameters(proxy, receipt);\nconst withdrawArray = [];\n\n// Check if the lengths of the arrays are the same\nlet status = 'Done';\nif (r.length !== s.length) {\n    status = 'Fail';\n    console.error(\"Arrays have different lengths,\", r, s);\n}\nelse {\n    for (let i = 0; i &lt; r.length; i++) {\n        const rItem = r[i];\n        const sItem = s[i];\n        if (rItem.address !== sItem.address || rItem.amount !== sItem.amount) {\n            console.log(\"Crash(Need manual review):\");\n            console.error(`Mismatch found: ${rItem.address}:${rItem.amount} ${sItem.address}:${sItem.amount}`);\n            while (1); //This is serious error, while loop to trigger manual review. This can be replaced by other methods to decently handle this error.\n            status = 'Fail';\n            break;\n        }\n        else {\n            record.withdrawArray.push({\n                address: rItem.address,\n                amount: rItem.amount,\n            });\n        }\n    }\n}\nrecord.settleTxHash = tx.hash;\nrecord.settleStatus = status;\nawait record.save();\n</code></pre> <p>Now you can refer to the Settlement Flow and Transaction Execution in zkWasm Protocol to learn how the proxy contract actually processes the withdraw transactions after the settlement monitor request to verify the proofs.</p>"},{"location":"zkwasm-protocol/zkWasm%20Protocol.html","title":"zkWasm Protocol Overview","text":""},{"location":"zkwasm-protocol/zkWasm%20Protocol.html#overview","title":"Overview","text":"<p>zkWasm-Protocol is a specialized blockchain protocol designed to facilitate the settlement of zkWASM mini-rollups. It provides a robust framework for handling zero-knowledge proof verification and transaction processing in a secure and efficient manner. Specifically, it enables deposits and withdrawals of assets between the zkWASM mini-rollup application and the on-chain zkWasm-Protocol.</p>"},{"location":"zkwasm-protocol/zkWasm%20Protocol.html#core-components","title":"Core Components","text":"<ul> <li>Proxy Contract: The central hub for transaction processing and state management for a specific application.</li> <li>Verifier (interface): Handles zero-knowledge proof verification, each blockchain can have its own verifier, and it can be used for all the applications which have deployed its proxy contract.</li> <li>Transaction (interface): Supports standardized 32-byte transaction format for processing side effects such as withdrawals which are triggered by settlement (proof verification). </li> <li>Other Contracts: Additional contracts like ERC20 and NFT Bidding for extended functionality</li> </ul>"},{"location":"zkwasm-protocol/zkWasm%20Protocol.html#proxy-contract","title":"Proxy Contract","text":""},{"location":"zkwasm-protocol/zkWasm%20Protocol.html#initialization","title":"Initialization","text":"<p>When you deploy a proxy contract, you set the chain id and the merkle root of the zkwasm application image: </p> <pre><code>constructor(uint32 chain_id, uint256 root) {\n    _proxy_info.chain_id = chain_id;\n    _proxy_info.owner = msg.sender;\n    merkle_root = root;\n    rid = 0;\n}\n</code></pre> <p>And the owner is set to be the deployer of the proxy contract.</p>"},{"location":"zkwasm-protocol/zkWasm%20Protocol.html#state-management","title":"State Management","text":"<p>In proxy contract, we have plenty of state variables to manage the state of the application:</p> <pre><code>TokenInfo[] public _tokens;\nTransaction[] public transactions;\nDelphinusVerifier public verifier;\nProxyInfo _proxy_info;\n\naddress internal _settler;\nuint256[3] public zk_image_commitments;\nuint256 public merkle_root;\nuint256 public rid;\nuint256 public withdrawLimit = 10000 * 1e18; //10000 Ti limit per settle\n\nmapping(uint256 =&gt; bool) private _tmap;\nmapping(uint256 =&gt; bool) private hasSideEffect;\n</code></pre> <p>Where:</p> <ul> <li><code>TokenInfo[] public _tokens;</code> is an array of all the tokens supported by the application.</li> <li><code>Transaction[] public transactions;</code> is an array of all the transaction types added to the proxy contract, such as withdrawals. </li> <li><code>DelphinusVerifier public verifier;</code> is the verifier for the application.</li> <li><code>ProxyInfo _proxy_info;</code> is the information of the proxy contract, including the chain id, added token amount, added pool amount, owner address, merkle root, rid, verifier id, etc.</li> <li><code>address internal _settler;</code> is the address of the settler, which can be set by the owner of the proxy contract.</li> <li><code>uint256[3] public zk_image_commitments;</code> is the commitments of the zkwasm application image.</li> <li><code>uint256 public merkle_root;</code> is the merkle root of the zkwasm application image.</li> <li><code>uint256 public rid;</code> indicates the settlement round id or number.</li> <li><code>uint256 public withdrawLimit = 10000 * 1e18; //10000 Ti limit per settle</code> is the limit of the withdrawals.</li> <li><code>mapping(uint256 =&gt; bool) private _tmap;</code> is a mapping of the token uids to the boolean value, indicating whether the token is supported by the application.</li> <li><code>mapping(uint256 =&gt; bool) private hasSideEffect;</code> is a mapping of the transaction uids to the boolean value, indicating whether the transaction has side effects.</li> </ul> <p>After the proxy contract is deployed, you have to specify the verifier contract address for the application, which is the verifier that will be used to verify the proofs of the transactions:</p> <pre><code>function setVerifier(address vaddr) public onlyOwner {\n    verifier = DelphinusVerifier(vaddr);\n}\n</code></pre> <p>You can also set the withdraw limit for the application, which is the maximum amount of withdrawal that can be processed in a single transaction:</p> <pre><code>function setWithdrawLimit(uint256 amount) public onlyOwner {\n    withdrawLimit = amount;\n}\n</code></pre> <p>Moreover, in order to ensure the verification is not misused (for example, someone may verify a proof generated from a different zkWasm application), we have to set the image commitment for the application:</p> <pre><code>function setVerifierImageCommitments(uint256[3] calldata commitments) external onlyOwner {\n    zk_image_commitments[0] = commitments[0];\n    zk_image_commitments[1] = commitments[1];\n    zk_image_commitments[2] = commitments[2];\n}\n</code></pre> <p>You can get the image commitment when you add the image to the zkWasm Hub or compute it by yourself using <code>ts/commitment.ts</code> in the zkWasm Mini=Rollup Repository.</p>"},{"location":"zkwasm-protocol/zkWasm%20Protocol.html#access-control","title":"Access Control","text":"<p>There are two kinds of access control in the proxy contract:</p> <pre><code>modifier onlyOwner() {\n    require(msg.sender == _proxy_info.owner, \"Only owner can call this function\");\n    _;\n}\n\nmodifier onlySettler() {\n    require(msg.sender == _settler, \"Only settler can call this function\");\n    _;\n}\n</code></pre> <ul> <li><code>onlyOwner</code> modifier is used to restrict access to the owner of the proxy contract.</li> <li><code>onlySettler</code> modifier is used to restrict access to the settler of the proxy contract.</li> </ul> <p>The owner and settler can be set by the owner of the proxy contract:</p> <pre><code>function setOwner(address new_owner) external onlyOwner {\n    _proxy_info.owner = new_owner;\n}\n\nfunction setSettler(address settler) external onlyOwner {\n    _settler = settler;\n}\n</code></pre>"},{"location":"zkwasm-protocol/zkWasm%20Protocol.html#token-management","title":"Token Management","text":"<p>An important feature of the proxy contract is to manage the tokens supported by the application, which is used for settlement operations such as transfer, withdraw, deposit, etc. </p> <p>The owner of the proxy contract can add or modify the tokens supported by the application:</p> <pre><code>function addToken(uint256 token) public onlyOwner returns (uint32) {\n    uint32 cursor = uint32(_tokens.length); // cursor is the index of the token in the _tokens array\n    _tokens.push(TokenInfo(token)); // add the token to the _tokens array\n    _proxy_info.amount_token = cursor + 1; // update the amount of the tokens supported by the application\n    require(_tmap[token] == false, \"AddToken: Token Already Exist\"); // check if the token is already supported\n    if (token != 0) {\n        _tmap[token] = true; // set the token to be supported\n    }\n    return cursor; // return the index of the token in the _tokens array\n}\n\n\nfunction modifyToken(uint32 index, uint256 token) public onlyOwner{\n    require(_tmap[token] == false, \"AddToken: Token Already Exist\");\n\n    // Check if the index is within bounds of the array\n    require(index &lt; _tokens.length, \"Index out of bounds\");\n\n    // Modify the token at the specified index\n    _tokens[index].token_uid = token;\n}\n</code></pre> <p>You may notice that the <code>token</code> parameter in the <code>addToken</code> and <code>modifyToken</code> functions is of type <code>uint256</code> instead of <code>address</code>. This is because the <code>token</code> is the uid of the token, which is derived from the token address and the chain id, for example, in <code>test/test_utils.ts</code>, we have the following code to derive the uid of the token and add it to the proxy contract:</p> <pre><code>import { ethers, getChainId } from \"hardhat\";\nimport { encodeL1address } from \"web3subscriber/src/addresses\";\nconst chainId = await getChainId();\nlet tokenUid = encodeL1address(tokenAddress.replace(\"0x\", \"\"), Number(chainId).toString(16));\nlet tokenUidString = tokenUid.toString(16);\nawait proxy.addToken(ethers.toBigInt(\"0x\" + tokenUidString));\n</code></pre> <p>Or in the proxy contract itself, we have <code>_l1_address</code> function to derive the uid of a token or an account:</p> <pre><code>function _l1_address(address account) public view returns (uint256) {\n    return\n        (uint256(uint160(account))) +\n        (uint256(_proxy_info.chain_id) &lt;&lt; 160);\n}\n</code></pre> <p>Why add chain id to the uid? This is because the uid is used to identify the token, and the chain id is used to identify the chain, so the uid is unique for a specific token on a specific chain. </p> <p>You can find if an uid is specific to the blockchain (by checking if the chain id included in the uid is the same as the chain id of the proxy contract) by calling the <code>_is_local</code> function:</p> <pre><code>function _is_local(uint256 l1address) public view returns (bool) {\n    return ((l1address &gt;&gt; 160) == (uint256(_proxy_info.chain_id)));\n}\n</code></pre> <p>You can view all the uids of the tokens supported by the application by calling the <code>allTokens</code> function:</p> <pre><code>function allTokens() public view returns (TokenInfo[] memory) {\n    return _tokens;\n}\n</code></pre>"},{"location":"zkwasm-protocol/zkWasm%20Protocol.html#transaction-management","title":"Transaction Management","text":"<p>The owner of the proxy contract can add the transaction types supported by the application:</p> <pre><code>function addTransaction(address txaddr, bool sideEffect) public onlyOwner returns (uint256) {\n    uint256 cursor = transactions.length; // cursor is the index of the transaction type in the transactions array\n    require(transactions.length &lt; 255, \"TX index out of bound\"); // check if the index of the transaction type is within bounds of the array\n    transactions.push(Transaction(txaddr)); // add the transaction type to the transactions array\n    if (sideEffect) {\n        hasSideEffect[cursor] = sideEffect; // set if the transaction type has side effects\n    }\n    return cursor; // return the index of the transaction type in the transactions array\n}\n</code></pre> <p>A common misunderstanding is to think that the transaction type is a \"real\" transaction which can be executed, but it is not. It is just a transaction type which represents a specific kind of transaction such as withdrawals. The parameter <code>txaddr</code> is the address of the deployed transaction type contract which implements the <code>Transaction</code> interface:</p> <pre><code>pragma solidity ^0.8.0;\n\nuint8 constant _WITHDRAW = 0x0;\n\ninterface Transaction {\n    function sideEffect(bytes calldata args, uint cursor) external pure returns (uint256[] memory);\n}\n</code></pre> <p>Here's an example of Withdraw.sol which implements the <code>Transaction</code> interface: <pre><code>pragma solidity ^0.8.0;\nimport \"../Transaction.sol\";\n\ncontract Withdraw is Transaction {\n    /*\n     * u8:op\n     * u8:token_index\n     * u16: reserve (le mode)\n     * u160: addr (be mode)\n     * u64: amount (be mode)\n     */\n    function sideEffect(bytes memory witness, uint256 cursor) public pure override returns (uint256[] memory) {\n        uint256[] memory ops = new uint256[](4);\n        uint256 data32; \n        uint256 offset = cursor + 32;\n        assembly {\n            // Load the 32 bytes of data from memory\n            data32 := mload(add(witness, offset))\n        }\n        //ops[0] = uint256( (data32 &gt;&gt; (31*8)) &amp; 0xFF );\n        ops[0] = _WITHDRAW;\n        // token index\n        ops[1] = uint256( (data32 &gt;&gt; (30*8)) &amp; 0x00FF );\n        // amount to withdraw (wei not considered\n        ops[2] = uint256( data32 &amp; 0xFFFFFFFFFFFFFFFF );\n        // recipient address\n        ops[3] = uint256( (data32 &gt;&gt; (8*8)) &amp; 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF );\n        return ops;\n    }\n}\n</code></pre> You will need to deploy the Withdraw.sol contract and add its address to the proxy contract through the <code>addTransaction</code> function to enable the withdrawals.</p>"},{"location":"zkwasm-protocol/zkWasm%20Protocol.html#settlement-flow","title":"Settlement Flow","text":"<p>If you have deployed the proxy contract, transaction types contracts, and added the transaction types and tokens, you can start the settlement flow by calling the <code>verify</code> function:</p> <pre><code>function verify(\n    bytes calldata tx_data,\n    uint256[] calldata proof,\n    uint256[] calldata verify_instance,\n    uint256[] calldata aux,\n    uint256[][] calldata instances\n) onlySettler nonReentrant public{...}\n</code></pre> <p>The <code>verify</code> function takes the following parameters:</p> <ul> <li><code>tx_data</code>: the data of the transactions to be processed.</li> <li><code>proof</code>: the proof of the transactions and state transition.</li> <li><code>verify_instance</code>: the commitments of the application image.</li> <li><code>aux</code>: the auxiliary data of the proof which is used to support the verification.</li> <li><code>instances</code>: the instances of the proof, including the sha256 hash of the transactions and merkle root before and after the state transition.</li> </ul> <p>To verify the proof, the function first checks if the commitments of the application image are correct:</p> <pre><code>if (zk_image_commitments[0] != 0) {\n    require(verify_instance[1] == zk_image_commitments[0], \"Invalid image commitment 0\");\n    require(verify_instance[2] == zk_image_commitments[1], \"Invalid image commitment 1\");\n    require(verify_instance[3] == zk_image_commitments[2], \"Invalid image commitment 2\");\n}\n</code></pre> <p>Then it checks if the transaction data is in valid format and the sha256 hash of the transaction data is consistent with the instances:</p> <pre><code>if (tx_data.length &gt; 1) {\n    require(\n        tx_data.length % OP_SIZE == 0,\n        \"Verify: Insufficient delta operations\"\n    );\n\n    uint256 sha_pack = uint256(sha256(tx_data));\n    require(\n        sha_pack ==\n            (instances[0][8] &lt;&lt; 192) +\n                (instances[0][9] &lt;&lt; 128) +\n                (instances[0][10] &lt;&lt; 64) +\n                instances[0][11],\n        \"Inconsistent: Sha data inconsistent\"\n    );\n}\n</code></pre> <p>Then it checks if the merkle root before the state transition is consistent with the instances:</p> <pre><code>require(\n    merkle_root ==\n        (instances[0][0] &lt;&lt; 192) +\n            (instances[0][1] &lt;&lt; 128) +\n            (instances[0][2] &lt;&lt; 64) +\n            instances[0][3],\n    \"Inconsistent: Merkle root dismatch\"\n);\n</code></pre> <p>Then it calls the <code>verify</code> function of the verifier contract to verify the proof and process the transactions:</p> <pre><code>if (tx_data.length &gt; 1) {\n    sideEffectCalled = perform_txs(tx_data);\n}\n\nuint256 new_merkle_root = (instances[0][4] &lt;&lt; 192) +\n    (instances[0][5] &lt;&lt; 128) +\n    (instances[0][6] &lt;&lt; 64) +\n    instances[0][7];\n</code></pre> <p>Finally, it checks if the new merkle root is consistent with the instances and updates the old merkle root with the new merkle root:</p> <pre><code>uint256 new_merkle_root = (instances[0][4] &lt;&lt; 192) +\n    (instances[0][5] &lt;&lt; 128) +\n    (instances[0][6] &lt;&lt; 64) +\n    instances[0][7];\nrid = rid + 1; // increment the rid\nmerkle_root = new_merkle_root; // update the merkle root\n</code></pre> <p>You may notice that the instances array use bit shift to pack the data, which is a common technique to save space in the proof, here's how the data is packed:</p> <pre><code>instances[0] layout (each element is 64 bits):\n\n[0-3]:   Current Merkle Root (256 bits total)\n  [0] - Highest 64 bits\n  [1] - Second highest 64 bits\n  [2] - Third highest 64 bits\n  [3] - Lowest 64 bits\n\n[4-7]:   New Merkle Root (256 bits total)\n  [4] - Highest 64 bits\n  [5] - Second highest 64 bits\n  [6] - Third highest 64 bits\n  [7] - Lowest 64 bits\n\n[8-11]:  Transaction Data Hash (256 bits total)\n  [8] - Highest 64 bits\n  [9] - Second highest 64 bits\n  [10] - Third highest 64 bits\n  [11] - Lowest 64 bits\n\ninstances[0] array (12 elements):\n+---------------+---------------+---------------+---------------+\n|     [0]       |     [1]       |     [2]       |     [3]       |\n| Current Root  | Current Root  | Current Root  | Current Root  |\n| (bits 255-192)| (bits 191-128)| (bits 127-64) | (bits 63-0)   |\n+---------------+---------------+---------------+---------------+\n|     [4]       |     [5]       |     [6]       |     [7]       |\n|  New Root     |  New Root     |  New Root     |  New Root     |\n| (bits 255-192)| (bits 191-128)| (bits 127-64) | (bits 63-0)   |\n+---------------+---------------+---------------+---------------+\n|     [8]       |     [9]       |    [10]       |    [11]       |\n|   TX Hash     |   TX Hash     |   TX Hash     |   TX Hash     |\n| (bits 255-192)| (bits 191-128)| (bits 127-64) | (bits 63-0)   |\n+---------------+---------------+---------------+---------------+\n</code></pre>"},{"location":"zkwasm-protocol/zkWasm%20Protocol.html#transaction-execution","title":"Transaction Execution","text":"<p>In settlement, the <code>perform_txs</code> function is called to execute the transactions:</p> <pre><code>function perform_txs(\n    bytes calldata tx_data\n) private returns (uint256){\n    uint256 ret = 0;\n    uint256 batch_size = tx_data.length / OP_SIZE;\n    for (uint i = 0; i &lt; batch_size; i++) {\n        uint8 op_code = uint8(bytesToUint(tx_data, i * OP_SIZE, 1));\n        require(transactions.length &gt; op_code, \"TX index out of bound\");\n        if (hasSideEffect[op_code]) {\n            Transaction transaction = _get_transaction(op_code);\n            uint256[] memory update = transaction.sideEffect(tx_data, i * OP_SIZE);\n            ret += 1;\n            _update_state(update);\n        }\n    }\n    return ret;\n}\n</code></pre> <p>The <code>tx_data</code> is the data of the transactions to be processed, each transaction is encoded in 32 bytes (<code>OP_SIZE = 32</code> so we divide the <code>tx_data</code> by <code>OP_SIZE</code> to get the number of transactions), and the <code>op_code</code> is the index of the transaction type in the <code>transactions</code> array: </p> <pre><code>Transaction Data Structure (32 bytes total)\n   [1 byte]  op_code (uint8)     // Operation code for transaction type, maximum 255 types\n   [1 byte]  token_index         // Index of the token in registry, maximum 255 tokens\n   [2 bytes] reserved            // Reserved for future use\n   [20 bytes] address            // Ethereum address (160 bits)\n   [8 bytes] amount             // Transaction amount value\n</code></pre> <p>For each transaction that has side effects, the function get the transaction type from the <code>transactions</code> array and call the <code>sideEffect</code> function of the transaction type contract to get the state updates information. Let's take a look at the <code>Withdraw.sol</code> contract to see how the state updates information is returned:</p> <pre><code>uint8 constant _WITHDRAW = 0x0;\nfunction sideEffect(bytes memory witness, uint256 cursor)\n    public\n    pure\n    override\n    returns (uint256[] memory)\n{\n    uint256[] memory ops = new uint256[](4);\n\n    uint256 data32;\n    uint256 offset = cursor + 32;\n    assembly {\n        // Load the 32 bytes of data from memory\n        data32 := mload(add(witness, offset))\n    }\n    //ops[0] = uint256( (data32 &gt;&gt; (31*8)) &amp; 0xFF );\n    ops[0] = _WITHDRAW;\n    // token index\n    ops[1] = uint256( (data32 &gt;&gt; (30*8)) &amp; 0x00FF );\n    // amount to withdraw (wei not considered\n    ops[2] = uint256( data32 &amp; 0xFFFFFFFFFFFFFFFF );\n    // recipient address\n    ops[3] = uint256( (data32 &gt;&gt; (8*8)) &amp; 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF );\n    return ops;\n}\n</code></pre> <p>Where <code>witness</code> is the complete transaction data (tx_data) and <code>cursor</code> is the starting position of current transaction (i * OP_SIZE, where i is the index of the transaction in the batch and OP_SIZE is 32). </p> <p>It returns an array of 4 elements (ops), where the ops has the following layout: <pre><code>+-------------+-------------+------------------+--------------------+\n|    ops[0]   |   ops[1]    |      ops[2]      |       ops[3]       |\n|  Operation  | Token Index |     Amount       | Recipient Address  |\n| (constant)  |  (8 bits)   |    (64 bits)     |    (160 bits)      |\n+-------------+-------------+------------------+--------------------+\n</code></pre></p> <p>Note</p> <p>You may find it hard to understand the assembly code and bit shift operations. You may skip this section if you are not interested in the details. </p> <p>First, let's understand how bytes memory is laid out: <pre><code>Memory Layout for 'bytes':\n+---------------+------------------------+-----------------+\n| Length (32B)  | Actual Data            | ...             |\n+---------------+------------------------+-----------------+\n\u2190 0x00          \u2190 0x20                  \u2190 0x40 ...\n</code></pre></p> <ul> <li>First 32 bytes (0x00-0x1F) stores the length of the bytes array located at the start of the memory allocation.</li> <li>Next 32 bytes (0x20-0x3F) stores the actual data of the bytes array. This is where our first transaction starts.</li> </ul> <p>And here's structure of the transaction data: <pre><code>Memory Position Calculation:\n+---------------+------------------+------------------+------------------+\n| Length (32B)  |  Transaction 1   | Transaction 2    | Transaction 3    |\n+---------------+------------------+------------------+------------------+\n\u2190 0x00          \u2190 0x20             \u2190 0x40             \u2190 0x60\n                \u2190 cursor=0         \u2190 cursor=32        \u2190 cursor=64\n                \u2190 offset=32        \u2190 offset=64        \u2190 offset=96\n</code></pre></p> <p>And that's why cursor needs to be added by 32, it is used to get the memory position of the transaction data to skip the length of the bytes array.</p> <pre><code>uint256 data32;                    // Will hold our 32 bytes of data\nuint256 offset = cursor + 32;      // Calculate the memory position\nassembly {\n    // add(witness, offset): Calculate final memory address\n    // mload: Load 32 bytes from that address into data32\n    data32 := mload(add(witness, offset))\n}\n</code></pre> <p>The <code>add</code> function is used to calculate the final memory address by adding the offset to the witness pointer. The <code>mload</code> function is used to load 32 bytes from that address into <code>data32</code>. Therefore, <code>data32</code> will hold the 32 bytes of the transaction data we want to extract.</p> <p>And the <code>data32</code> is then used to extract the operation code, token index, amount, and recipient address from the transaction data. For example:</p> <pre><code>ops[1] = uint256( (data32 &gt;&gt; (30*8)) &amp; 0x00FF ); //extract the token index\n</code></pre> <p>This operation shifts <code>data32</code> right by 30*8 bits (which is 240 bits) and then performs a bitwise AND with <code>0x00FF</code> (which is 255 in decimal). This effectively extracts the last 8 bits of <code>data32</code>, which correspond to the token index: </p> <pre><code>Original data32 (32 bytes):\n+----+----+------+--------------------+------------------+\n|op  |tidx|reserv|       address      |      amount      |\n+----+----+------+--------------------+------------------+\n 31    30   29-28        27-8                 7-0\n\nStep 1: Right Shift (&gt;&gt; 30*8)\nBefore: 0x[01][02][0000][1234...5678][000F4240]\n                \u2193 shift right 240 bits (30 bytes)\nAfter:  0x0000...0000[01][02]\n\nStep 2: AND with 0x00FF\n0x0000...0000[01][02]\n         AND\n0x0000...0000[00][FF]\n         =\n0x0000...0000[00][02] \u2190 Final token index value\n</code></pre> <p>After get the ops (which contains the operation code, token index, amount, and recipient address), the function <code>perform_txs</code> will call the <code>_update_state</code> function to execute the transaction and update the state of the application:</p> <pre><code>/*\n* @dev side effect encoded in the update function\n* deltas = [| opcode; args |]\n*/\nfunction _update_state(uint256[] memory deltas) private {\n    uint256 cursor = 0;\n    while (cursor &lt; deltas.length) {\n        uint256 delta_code = deltas[cursor];\n        if (delta_code == _WITHDRAW) {\n            require(\n                deltas.length &gt;= cursor + 4,\n                \"Withdraw: Insufficient arg number\"\n            );\n            _withdraw(\n                uint128(deltas[cursor + 1]),\n                uint128(deltas[cursor + 2]),\n                deltas[cursor + 3]\n            );\n            cursor = cursor + 4;\n        } else {\n            revert(\"SideEffect: UnknownSideEffectCode\");\n        }\n    }\n}\n</code></pre> <p>Note that the <code>deltas</code> array is the <code>update</code> array in the <code>perform_txs</code> function and it is the <code>ops</code> array in the <code>sideEffect</code> function. The function matches the <code>delta_code</code> with the operation code and call the corresponding function (<code>_withdraw</code>) to update the state of the application: </p> <pre><code>/* In convention, the wasm image does not take wei into consideration thus we need to apply  amout * 1e18 * to get the actual amount of withdraw. Please make sure the wei of the withdraw token is 18\n*/\nfunction _withdraw(\n    uint128 tidx,\n    uint128 amount,  //in ether\n    uint256 l1recipent\n) private {\n    uint256 tokenid = get_token_uid(tidx);\n    if (_is_local(tokenid)) {\n        address token = address(uint160(tokenid));\n        address recipent = address(uint160(l1recipent));\n        // Sanity checks\n        require(recipent != address(0), \"Withdraw to the zero address\");\n        IERC20 underlying_token = IERC20(token);\n        uint256 balance = underlying_token.balanceOf(address(this));\n        require(balance &gt;= amount * 1e18, \"Insufficient balance for withdraw\");\n        require(amount * 1e18 &lt;= withdrawLimit, \"Withdraw amount exceed limit\");\n        TransferHelper.safeTransfer(address(underlying_token), recipent, amount * 1e18);\n        emit WithDraw(token, recipent, amount * 1e18);\n    }\n}\n</code></pre> <p>The <code>_withdraw</code> function is straightforward, it will transfer the amount of the withdraw token to the recipient address.</p>"},{"location":"zkwasm-protocol/zkWasm%20Protocol.html#verifier-interface","title":"Verifier Interface","text":"<p>This is the interface of the verifier contract, which is used to verify the proof and process the transactions in the proxy contract.</p> <p><pre><code>interface DelphinusVerifier {\n    /**\n     * @dev snark verification stub\n     */\n    function verify (\n        uint256[] calldata proof,\n        uint256[] calldata verify_instance,\n        uint256[] calldata aux,\n        uint256[][] calldata target_instance\n    ) external view;\n}\n</code></pre> Parameters</p> <ul> <li>proof<ul> <li>Contains the zero-knowledge proof data</li> <li>Generated by the zkWasm prover</li> <li>Used to verify state transitions</li> </ul> </li> <li>verify_instance<ul> <li>Contains verification instance data</li> <li>Includes image commitments</li> </ul> </li> <li>aux<ul> <li>Auxiliary data for proof verification</li> <li>Contains helper values for computation</li> <li>Used to optimize verification process</li> </ul> </li> <li>target_instance<ul> <li>2D array containing state transition data</li> <li>First dimension: Multiple instances</li> <li>Second dimension: State values such as merkle root and transaction hash.</li> <li>Structure matches the instances array format described earlier</li> </ul> </li> </ul>"},{"location":"zkwasm-protocol/zkWasm%20Protocol.html#transaction-interface","title":"Transaction Interface","text":"<p>The transaction interface is used to define the transaction types supported by the application. The transaction type contract must implement the <code>sideEffect</code> function to return the state updates information.</p> <pre><code>uint8 constant _WITHDRAW = 0x0;\n// Additional operation codes can be defined here\n\ninterface Transaction {\n    function sideEffect(bytes calldata args, uint cursor) external pure returns (uint256[] memory);\n}\n</code></pre> <p>You can define your own operation code for the transaction type contract which implements this interface. The <code>sideEffect</code> function shall return the state updates information in the format like follows:</p> <pre><code>[operation, param1, param2, param3, ...]\n\nFor WITHDRAW operations:\n[_WITHDRAW, token_index, amount, recipient_address]\n</code></pre>"}]}